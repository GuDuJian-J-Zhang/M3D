#include "m3d/renderer/gl20/ShaderSrcCode.h"

namespace M3D
{
#define ENT "\n"
#define TOSTR(a) #a


	ShaderSrcCode::ShaderSrcCode()
	{
		// TODO Auto-generated constructor stub
	}

	ShaderSrcCode::~ShaderSrcCode()
	{
		// TODO Auto-generated destructor stub
	}

#ifdef WIN32
	const char* ShaderSrcCode::BackgroundVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec4 a_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"out vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = a_color;\n"
			"}\n"
			;
	}

	const char* ShaderSrcCode::BackgroundFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"in vec4 v_color;\n"
			"void main() { \n"
			"FragColor = v_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ModelBaseVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"in vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"out vec3 v_viewDirection;\n"
			"out vec3 v_lightDirection;\n"
			"out vec3 v_normal;\n"
			"out vec4 v_texCoords;\n"
			"out vec3 v_position;\n"
			"void main() { \n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"v_texCoords = tempCoords;\n"
			"v_viewDirection  = normalize(u_eyePosition -fvObjectPosition.xyz);\n"
			"v_lightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			" v_normal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::ModelBaseFrag()
	{
		return
			"#version 130 \n"
			"#extension GL_OES_standard_derivatives:enable \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"uniform bool u_useTex;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"in vec3 v_viewDirection;\n"
			"in vec3 v_lightDirection;\n"
			"in vec3 v_normal;\n"
			"in vec4 v_texCoords;\n"
			"in vec3 v_position;\n"
			"vec2 sphereMap(vec3 normal, vec3 ecPosition3){\n"
			"float m;\n"
			"vec3 r;\n vec3 u;\n"
			"u = normalize(ecPosition3);\n"
			"r = reflect(u, normal);\n"
			"m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0))+0.0001;\n"
			"return vec2 (r.x / m + 0.5, r.y / m + 0.5);\n"
			"}\n"
			"const vec4 ambientColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const vec4 diffuseColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const float shiness = 30.0;\n"
			"const vec4 specularColor = vec4(0.5,0.5,0.5,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"void main() { \n"
			"float fNDotL =0.0;\n"
			"vec3 	halfvector;\n"
			"float fNDotH;"
			" vec3  fvNormal ;\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"if(gl_FrontFacing){\n"
			" fvNormal         = normalize( v_normal );\n"
			"}\n"
			"else {\n"
			" fvNormal         = normalize( -v_normal );\n"
			"}\n"
			"vec2 sphereCoords = sphereMap(fvNormal,v_position);\n"
			"//switchColor = switchColor * texture2D(u_sampler1,sphereCoords.xy);\n"
			" fNDotL           = clamp(dot( fvNormal, v_lightDirection ),0.001,1.0);\n"
			"halfvector        =normalize(v_lightDirection+ v_viewDirection );\n"
			" fNDotH            = dot(fvNormal,halfvector);\n"
			"if(u_useTex){\n"
			"switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"}\n"
			"vec4  fvTotalAmbient   = u_ambient * ambientColor;\n"
			"vec4  fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor; \n"
			"vec4  fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), shiness ) );\n"
			"vec4 colorLinear = fvTotalAmbient + fvTotalDiffuse + fvTotalSpecular;\n"
			"FragColor = vec4(colorLinear.xyz,u_diffuse.a);\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::EdgeVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec3 v_position;\n"
			"#ifdef DEPTH_EDGE\n"
			"out vec4 v_projectPos;\n"
			"#endif\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"#ifdef DEPTH_EDGE\n"
			"v_projectPos = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"#endif\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"gl_PointSize = 3.0;\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::EdgeFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"#ifdef DEPTH_EDGE\n"
			"uniform sampler2D u_sampler0;\n"
			"in vec4 v_projectPos;\n"
			"#endif\n"
			"in vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"float testvalue = (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
			"if( testvalue<0.0)\n"
			"  {\n"
			" discard;\n"
			"}\n"
			"}\n"
			"#ifdef DEPTH_EDGE\n"
			"vec3 proj =v_projectPos.xyz/v_projectPos.w;\n "
			"   proj = proj *0.5+0.5;\n"
			"float priDepth = texture2D(u_sampler0,proj.xy).x;\n"
			"if(priDepth<proj.z) discard;\n"
			"#endif\n"
			"FragColor = u_diffuse;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::WireframeVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec3 v_center;\n"
			"void main(){\n"
			"v_center = a_normal;\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::WireframeFrag()
	{
		return
			"#version 130 \n"
			"#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_diffuse;\n"
			"in vec3 v_center;\n"
			"float edgeFactorTri() {\n"
			"vec3 d = fwidth( v_center.xyz );\n"
			"vec3 a3 = smoothstep( vec3( 0.0 ), d * 1.5, v_center.xyz );\n"
			"return min( min( a3.x, a3.y ), a3.z );\n"
			"}\n"
			"void main() { \n"
			"FragColor.rgb = mix( vec3( 1.0 ), vec3( 0.2 ), edgeFactorTri() );\n"
			"FragColor.a = 1.0;\n"
			"}\n"
			;
	}


	const char* ShaderSrcCode::BrdfVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"in vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"out vec3 v_viewDirection;\n"
			"out vec3 v_lightDirection;\n"
			"out vec3 v_normal;\n"
			"out vec4 v_texCoords;\n"
			"out vec3    v_position;"
			"out vec4 v_worldPosition;\n"
			"void main() { \n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 v_worldPosition = u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_texCoords = tempCoords;\n"
			"v_position = fvObjectPosition.xyz;\n"
			"v_viewDirection  = normalize( -fvObjectPosition.xyz);\n"
			"v_lightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			" v_normal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"}\n"
			;
	}

	const char* ShaderSrcCode::BrdfFrag()
	{
		return
			"#version 130 \n"
			"#extension GL_OES_standard_derivatives:enable \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform bool u_useTex;\n"
			"uniform float u_fresnel0;\n"
			"uniform float u_roughness;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"in vec3 v_viewDirection;\n"
			"in vec3 v_lightDirection;\n"
			"in vec3 v_normal;\n"
			"in vec4 v_texCoords;\n"
			"in vec3    v_position;"
			"in vec4 v_worldPosition;\n"
			"const vec3 ambientColor = vec3(1.0, 1.0, 1.0);\n"
			"const vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n"
			"const float shiness = 65.0;\n"
			"const vec4 specularColor = vec4(0.5,0.5,0.5,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"float fresnel(float f0, vec3 n, vec3 l){\n"
			"return f0 + (1.0-f0) * pow(1.0- dot(n, l), 5.0);\n"
			"}\n"
			"float distribution(vec3 n, vec3 h, float roughness){\n"
			"float m_Sq= roughness * roughness;\n"
			"float NdotH_Sq= max(dot(n, h), 0.01);\n"
			"NdotH_Sq= NdotH_Sq * NdotH_Sq;\n"
			"return exp( (NdotH_Sq - 1.0)/(m_Sq*NdotH_Sq) )/ (3.14159265 * m_Sq * NdotH_Sq * NdotH_Sq) ;\n"
			"}\n"
			"float geometry(vec3 n, vec3 h, vec3 v, vec3 l, float roughness){\n"
			"float NdotH= dot(n, h);\n"
			"float NdotL= dot(n, l);\n"
			"float NdotV= dot(n, v);\n"
			"float VdotH= dot(v, h);\n"
			"float NdotL_clamped= max(NdotL, 0.01);\n"
			"float NdotV_clamped= max(NdotV, 0.01);\n"
			"return min( min( 2.0 * NdotH * NdotV_clamped / VdotH, 2.0 * NdotH * NdotL_clamped / VdotH), 1.0);\n"
			"}\n"
			"float diffuseEnergyRatio(float f0, vec3 n, vec3 l){\n"
			" return 1.0 - fresnel(f0, n, l);\n"
			"  }\n"
			"void main() { \n"
			"vec3  fvLightDirection;\n"
			" vec3  fvNormal ;\n"
			" vec3 normal;\n "
			"vec3 view;\n"
			" vec3 halfVec;\n"
			"float NdotL;\n"
			"float NdotV;\n"
			"float NdotL_clamped;\n"
			"float NdotV_clamped;\n"
			"float brdf_spec;\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"if(gl_FrontFacing){\n"
			" fvNormal         = normalize( v_normal );\n"
			"}\n"
			"else {\n"
			" fvNormal         = normalize( -v_normal );\n"
			"}\n"
			"fvLightDirection = normalize( v_lightDirection );\n"
			" normal =  normalize(fvNormal);\n"
			"view   = normalize(v_viewDirection);\n"
			" halfVec=  normalize(fvLightDirection + view);\n"
			"NdotL= dot(normal, fvLightDirection);\n"
			"NdotV= dot(normal, view);\n"
			"NdotL_clamped= max(NdotL, 0.01);\n"
			"NdotV_clamped= max(NdotV, 0.01);\n"
			"brdf_spec= fresnel(u_fresnel0, halfVec, fvLightDirection) * \n"
			" geometry(normal, halfVec, view, fvLightDirection, u_roughness) * \n"
			"distribution(normal, halfVec, u_roughness) / (4.0 * NdotL_clamped * NdotV_clamped);\n"
			"if(u_useTex){\n"
			"switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"}\n"
			"vec3 color_spec = NdotL_clamped * brdf_spec * diffuseColor;\n"
			"vec3 color_diff = switchColor.xyz*NdotL_clamped * diffuseEnergyRatio(u_fresnel0, normal, fvLightDirection) * vec3(u_diffuse.xyz) * diffuseColor;\n"
			" FragColor = vec4( color_diff + color_spec, u_diffuse.a)  ; \n"
			"}\n";
	}

	const char * ShaderSrcCode::AxisVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"uniform vec4 u_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"out vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = u_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::AxisFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"in vec4 v_color;\n"
			"void main() { \n"
			"FragColor = v_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ImageVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec2 v_texCoords;\n"
			"out vec3 v_position;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ImageFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"in vec2 v_texCoords;\n"
			"in vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"vec4 pcolor = texture2D(u_sampler0,v_texCoords);\n"
			"vec4 tcolor = pcolor*u_diffuse;\n"
			"FragColor = vec4(tcolor.xyz,pcolor.a);\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::CubeMapVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec3 v_cubeTexCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_cubeTexCoords = a_position;\n"
			"}\n";
	}
	const char * ShaderSrcCode::CubeMapFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform samplerCube u_samplerCube0;\n"
			"in vec3 v_cubeTexCoords;\n"
			"void main() { \n"
			"vec4 pcolor = texture(u_samplerCube0,v_cubeTexCoords);\n"
			"FragColor = pcolor;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ClipPlaneVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"uniform vec4 u_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"out vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = u_color;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ClipPlaneFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"in vec4 v_color;\n"
			"void main() { \n"
			"FragColor = v_color;\n"
			"}\n";
	}

	const char * ShaderSrcCode::MultilightVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"//#define FBO \n"
			"struct Light\n"
			"{\n"
			"    vec4 ambient;\n"
			"    vec4 diffuse;\n"
			"    vec4 specular;\n"
			"    vec4 position;\n"
			"    vec3 intensity;\n"
			"    vec3 spotDirection;\n"
			"    float spotExponent;\n"
			"    float spotCutoff; // (range: [0.0,90.0], 180.0)\n"
			"    float spotCosCutoff; // (range: [1.0,0.0],-1.0)\n"
			"    float constant;\n"
			"    float linear;\n"
			"    float quadratic;\n"
			"};\n"
			"\n"
			"struct LightModel\n"
			"{\n"
			"    vec4 ambient;    // Acs\n"
			"};\n"
			"\n"
			"struct Materials\n"
			"{\n"
			"    vec4 emission;\n"
			"    vec4 ambient;\n"
			"    vec4 diffuse;\n"
			"    vec4 specular;\n"
			"    float shininess;\n"
			"};\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"in vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"#ifdef FBO \n"
			"uniform mat4 u_lightMat;\n"
			"uniform mat4 u_lightProject;\n"
			"#endif \n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_eyePosition;\n"
			"\n"
			"//out\n"
			"out vec3 v_position;\n"
			"out vec4 v_texCoords;\n"
			"out vec3 v_diffuseColor;\n"
			"out vec3 v_specularColor;\n"
			"out vec3 v_diffuseColorN;\n"
			"out vec3 v_specularColorN;\n"
			"out vec3 v_normal;\n"
			"out vec3 v_cubeTexCoords;\n"
			"#ifdef FBO \n"
			"out vec4 v_lightSpacePos;\n"
			"out vec3 v_worldNormal;\n"
			"out vec3 v_worldPos;\n"
			"uniform vec3 u_shadowLPos;\n"
			"#endif \n"
			"//scene ambient\n"
			"uniform LightModel u_lightModel ;\n"
			"const int numberOfLights = 1;\n"
			"uniform Light u_lights[1];\n"
			"uniform int u_enbleLights[1];\n"
			"//Materials\n"
			"uniform Materials u_materials;\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    vec3 lightDirection;\n"
			"    float attenuation=1.0;\n"
			"    vec3 totalLighting = vec3(u_materials.emission)+ vec3(u_lightModel.ambient) * vec3(u_materials.ambient);\n"
			"    vec3 totalAmbient= vec3(0.0,0.0,0.0);\n"
			"    vec3 totalDiffuse = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalSpecular = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalAmbientBack= vec3(0.0,0.0,0.0);\n"
			"    vec3 totalDiffuseBack = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalSpecularBack = vec3(0.0,0.0,0.0);\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"#ifdef FBO \n"
			"    v_lightSpacePos = u_lightProject*u_lightMat *u_modelMat* vec4(a_position,1.0);\n"
			"    v_worldNormal = a_normal;\n"
			"#endif \n"
			"    vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"    v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"    v_texCoords = tempCoords;\n"
			"    vec3 vNormal= normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"    v_normal = vNormal;\n"
			"    vec4 worldPos = u_modelMat * vec4(a_position,1.0);\n"
			"    vec3 worldPosT = worldPos.xyz;\n"
			"    v_cubeTexCoords =reflect(normalize(worldPosT -u_eyePosition), normalize(a_normal));\n"
			"#ifdef FBO\n"
			"   v_worldPos = worldPosT;\n"
			"#endif\n"
			"    for(int index = 0;index<numberOfLights;index++)\n"
			"    {\n"
			"        if(u_enbleLights[index] == 1)\n"
			"        {\n"
			"\n"
			"            if (0.0 == u_lights[index].position.w) // directional light?\n"
			"            {\n"
			"                attenuation = 1.0; // no attenuation\n"
			"                lightDirection = normalize(vec3(u_lights[index].position));\n"
			"            }\n"
			"            else // point light or spotlight (or other kind of light)\n"
			"            {\n"
			"                vec3 positionToLightSource = vec3(u_lights[index].position) - fvObjectPosition.xyz ;\n"
			"                float distance = length(positionToLightSource);\n"
			"                lightDirection = normalize(positionToLightSource);\n"
			"                float tempA= u_lights[index].constant + u_lights[index].linear * distance + u_lights[index].quadratic * distance * distance;\n"
			"                attenuation = 1.0 / tempA;\n"
			"                if (u_lights[index].spotCutoff <= 90.0) // spotlight?\n"
			"                {\n"
			"                    float clampedCosine = max(0.0001, dot(lightDirection, -normalize(u_lights[index].spotDirection)));\n"
			"                    if (clampedCosine < u_lights[index].spotCosCutoff) // outside of spotlight cone?\n"
			"                    {\n"
			"                        attenuation = 0.0;\n"
			"                    }\n"
			"                    else\n"
			"                    {\n"
			"                        attenuation = attenuation * pow(clampedCosine, u_lights[index].spotExponent);\n"
			"//attenuation *= clamp((clampedCosine-cos(radians(15.0)) ) / (cos(radians(10.0)) - cos(radians(15.0))), 0.0, 1.0);\n"
			"                    }\n"
			"                }\n"
			"            }\n"
			"\n"
			"         //a side\n"
			"        float fNDotL= clamp(abs(dot( vNormal, lightDirection )),0.3,1.0);\n"
			"        vec3 diffuseReflection = attenuation\n"
			"            * vec3(u_lights[index].diffuse) * vec3(u_materials.diffuse)\n"
			"            * fNDotL;\n"
			"        //the othor\n"
			"        fNDotL= clamp(abs(dot( -vNormal, lightDirection )),0.3,1.0);\n"
			"        vec3 diffuseReflectionBack = attenuation\n"
			"            * vec3(u_lights[index].diffuse) * vec3(u_materials.diffuse)\n"
			"            * fNDotL;\n"
			"\n"
			"         totalAmbient =vec3(totalAmbient) + vec3(u_lights[index].ambient) * vec3(u_materials.ambient);\n"
			"		  float intensity = u_lights[index].intensity.x;\n"
			"         totalDiffuse = totalDiffuse + diffuseReflection*intensity;\n"
			"         totalDiffuseBack = totalDiffuseBack + diffuseReflectionBack*intensity;\n"
			"\n"
			"        vec3 eyeDirection = normalize(- fvObjectPosition.xyz );\n"
			"        vec3 halfVector = normalize(lightDirection+ eyeDirection);\n"
			"\n"
			"		vec3 tempsp = vec3(u_lights[index].specular);\n"
			"		float spv =  tempsp.x*tempsp.x+tempsp.y*tempsp.y+tempsp.z*tempsp.z;\n"
			"			if(spv>0.0){\n"
			"        //a side\n"
			"        float fNDotH = max(0.0, abs(dot(vNormal,halfVector)));\n"
			"        vec3 specularReflection = attenuation * vec3(u_lights[index].specular) * vec3(u_materials.specular)\n"
			"               * pow(fNDotH, u_materials.shininess);\n"
			"        //the other\n"
			"        fNDotH = max(0.0, abs(dot(-vNormal,halfVector)));\n"
			"        vec3 specularReflectionBack = attenuation * vec3(u_lights[index].specular) * vec3(u_materials.specular)\n"
			"               * pow(fNDotH, u_materials.shininess);\n"
			"\n"
			"         totalSpecular = totalSpecular + specularReflection*intensity;\n"
			"         totalSpecularBack = totalSpecularBack + specularReflectionBack*intensity;\n"
			"			}\n"
			"        }\n"
			"    }\n"
			"    v_diffuseColor = min(totalLighting+totalAmbient+totalDiffuse,vec3(1.0));\n"
			"    v_specularColor = min(totalSpecular,vec3(1.0));\n"
			"\n"
			"    v_diffuseColorN = min(totalLighting+totalAmbient+totalDiffuseBack,vec3(1.0));\n"
			"    v_specularColorN = min(totalSpecularBack,vec3(1.0));\n"
			" }\n"

			;
	}
	const char * ShaderSrcCode::MultilightFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"//#define FBO \n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform bool u_useTex;\n"
			"uniform bool u_useAmbientTex;\n"
			"uniform bool u_useCubeMapTex;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"uniform sampler2D u_sampler2;\n"
			"uniform samplerCube u_samplerCube0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_selectColor;\n"
			"in vec3 v_position;\n"
			"in vec4 v_texCoords;\n"
			"in vec3 v_diffuseColor;\n"
			"in vec3 v_specularColor;\n"
			"in vec3 v_diffuseColorN;\n"
			"in vec3 v_specularColorN;\n"
			"in vec3 v_normal;\n"
			"in vec3 v_cubeTexCoords;\n"
			"#ifdef FBO \n"
			"in vec4 v_lightSpacePos;\n"
			"in vec3 v_worldNormal;\n"
			"in vec3 v_worldPos;\n"
			"uniform vec3 u_shadowLPos;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"#endif \n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 environment = vec4(1.0);\n"
			"#ifdef FBO \n"
			"float ShadowCalculate(sampler2D sampler,vec4 fragPosLightSpace)\n"
			"{\n"
			"   float shadow = 1.0;\n"
			"	vec3 proj =fragPosLightSpace.xyz/fragPosLightSpace.w;\n"
			"   proj = proj *0.5+0.5;\n"
			"   float currentDepth = proj.z;\n"
			"   vec3 normal = normalize(v_worldNormal);\n"
			"   vec3 lightDir = normalize(u_shadowLPos-v_worldPos);\n"
			"   float bias = max(0.05*(1.0-dot(normal,lightDir)),0.005);\n"
			"   for(int y=-1; y<=1;y++)\n"
			"   {\n"
			"       for(int x=-1; x<=1;x++)\n"
			"        {\n"
			"  				 float closeDepth = texture2D(sampler,(proj+vec3(float(x)*u_xPixelOffset,float(y)*u_yPixelOffset,0.05)).xy).x;\n "
			"                shadow += (closeDepth<(currentDepth-bias))?0.5:1.0;\n"
			"         }\n"
			"    }\n"
			"   shadow /=16.0;\n"
			"   shadow += 0.2;\n"
			"   return shadow;\n"
			"}\n"
			"#endif \n"
			"vec2 sphereMap(vec3 normal, vec3 ecPosition3)\n"
			"{\n"
			"   float m;\n"
			"   vec3 r;\n"
			"   vec3 u;\n"
			"   u = normalize(ecPosition3);\n"
			"   r = reflect(u, normal);\n"
			"   m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0))+0.0001;\n"
			"   return vec2 (r.x / m + 0.5, r.y / m + 0.5);\n"
			"}\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip)\n"
			"    {\n"
			"       float dPara = u_clipPlane.w;\n"
			"		float testvalue = (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
			"        if( testvalue<0.0)\n"
			"        {\n"
			"            discard;\n"
			"        }\n"
			"    }\n"
			"    if(u_useTex)\n"
			"    {\n"
			"        switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"    }\n"
			"    if(u_useAmbientTex)\n"
			"    {\n"
			"        vec2 sphereCoords = sphereMap(v_normal,v_position);\n"
			"        environment = texture2D(u_sampler1,sphereCoords.xy);\n"
			"    }\n"
			"    if(u_useCubeMapTex)\n"
			"    {\n"
			"        environment = texture(u_samplerCube0,v_cubeTexCoords.xyz);\n"
			"    }\n"
			"    vec4 texColor = switchColor *environment;\n"
			" 	float shadow = 1.0;\n"
			"#ifdef FBO \n"
			"	 shadow = ShadowCalculate(u_sampler2,v_lightSpacePos);\n"
			"#endif \n"
			"	float alpha = u_diffuse.a;\n"
			"    if(gl_FrontFacing)\n"
			"    {\n"
			"        FragColor = vec4(vec3(texColor)*v_diffuseColor*(shadow)*vec3(u_selectColor)+vec3(v_specularColor)*(shadow),alpha);\n"
			"    }\n"
			"    else\n"
			"    {\n"
			"        FragColor = vec4(vec3(texColor)*v_diffuseColorN*(shadow)*vec3(u_selectColor)+vec3(v_specularColorN)*(shadow),alpha);\n"
			"    }\n"
			"}\n"
			"\n"

			;
	}

	const char * ShaderSrcCode::BaseVertexVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"in vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"vec3 vviewDirection;\n"
			"vec3 vlightDirection;\n"
			"vec3 vnormal;\n"
			"out vec3 v_position;\n"
			"out vec4 v_texCoords;\n"
			"out vec4 v_diffuseColor;\n"
			"out vec4 v_specularColor;\n"
			"out vec4 v_diffuseColorN;\n"
			"out vec4 v_specularColorN;\n"
			"out vec3 v_normal;\n"
			"const vec4 ambientColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const vec4 diffuseColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"uniform float u_shininess;\n"
			"const vec4 specularColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"void main() {\n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"v_texCoords = tempCoords;\n"
			"vviewDirection  = normalize( -fvObjectPosition.xyz);\n"
			"vlightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			"vnormal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"v_normal = vnormal;\n"
			"float fNDotL =0.0;\n"
			"vec3 halfvector;\n"
			"float fNDotH;\n"
			"fNDotL           = clamp(abs(dot( vnormal, vlightDirection )),0.3,1.0);\n"
			"halfvector        =normalize(vlightDirection+ vviewDirection );\n"
			"fNDotH            = dot(vnormal,halfvector);\n"
			"vec4  fvTotalAmbient   = u_ambient * ambientColor;\n"
			"vec4  fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"vec4  fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColor=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColor = min(fvTotalSpecular,vec4(1.0));\n"
			"\n"
			"fNDotL           = clamp(abs(dot( -vnormal, vlightDirection )),0.3,1.0);\n"
			"fNDotH            = dot(-vnormal,halfvector);\n"
			"fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColorN=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColorN = min(fvTotalSpecular,vec4(1.0));\n"
			""
			"}\n"
			"\n"


			;
	}
	const char * ShaderSrcCode::BaseVertexFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform bool u_useTex;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_selectColor;\n"
			"in vec3 v_position;\n"
			"in vec4 v_texCoords;\n"
			"in vec4 v_diffuseColor;\n"
			"in vec4 v_specularColor;\n"
			"in vec4 v_diffuseColorN;\n"
			"in vec4 v_specularColorN;\n"
			"in vec3 v_normal;\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 environment = vec4(1.0);\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip){\n"
			"        float dPara = u_clipPlane.w;\n"
			"        if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"                    discard;\n"
			"            }\n"
			"    }\n"
			"    if(u_useTex){\n"
			"          switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"                }\n"
			"	vec4 texColor = switchColor *environment;\n"
			"    if(gl_FrontFacing){\n"
			"    	  FragColor = vec4(vec3(texColor*v_diffuseColor)*vec3(u_selectColor)+vec3(v_specularColor),u_diffuse.a+1.0);\n"
			"    }else{\n"
			"         FragColor = vec4(vec3(texColor*v_diffuseColorN)*vec3(u_selectColor)+vec3(v_specularColorN),u_diffuse.a+1.0);\n"
			"    }\n"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::ShadowMapVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec3 v_position;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ShadowMapFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"in vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"FragColor = vec4(gl_FragCoord.z,gl_FragCoord.z,gl_FragCoord.z,1.0);\n"
			"}\n"
			;
	}


	const char * ShaderSrcCode::FBODebugVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec2 v_texCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::FBODebugFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform sampler2D u_sampler0;\n"
			"in vec2 v_texCoords;\n"
			"in vec3 v_position;\n"
			"void main() { \n"
			"vec4 pcolor = texture2D(u_sampler0,v_texCoords);\n"
			"vec4 tcolor = pcolor;\n"
			"FragColor = tcolor;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::PlaneShadowVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"#define FBO \n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"#ifdef FBO \n"
			"uniform mat4 u_lightMat;\n"
			"uniform mat4 u_lightProject;\n"
			"#endif \n"
			"\n"
			"out vec3 v_position;\n"
			"#ifdef FBO \n"
			"out vec4 v_lightSpacePos;\n"
			"out vec3 v_worldNormal;\n"
			"out vec3 v_worldPos;\n"
			"#endif \n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    vec3 lightDirection;\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"#ifdef FBO \n"
			"    v_lightSpacePos = u_lightProject*u_lightMat *u_modelMat* vec4(a_position,1.0);\n"
			"    v_worldNormal = a_normal;\n"
			"#endif \n"
			"    vec4 worldPos = u_modelMat * vec4(a_position,1.0);\n"
			"    v_worldPos = worldPos.xyz;\n"
			" }\n";
	}
	const char * ShaderSrcCode::PlaneShadowFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"#define FBO \n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"in vec3 v_position;\n"
			"#ifdef FBO \n"
			"in vec4 v_lightSpacePos;\n"
			"in vec3 v_worldNormal;\n"
			"in vec3 v_worldPos;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform vec3 u_shadowLPos;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"#endif \n"
			"float ShadowCalculate(sampler2D sampler,vec4 fragPosLightSpace)\n"
			"{\n"
			"   float shadow = 1.0;\n"
			"	vec3 proj =fragPosLightSpace.xyz/fragPosLightSpace.w;\n"
			"   proj = proj *0.5+0.5;\n"
			"  if(proj.x>1.0 || proj.x<0.0 || proj.y>1.0 || proj.y<0.0) return 1.0;\n"
			"   float currentDepth = proj.z;\n"
			"   vec3 normal = normalize(v_worldNormal);\n"
			"   vec3 lightDir = normalize(u_shadowLPos-v_worldPos);\n"
			"   float bias = max(0.05*(1.0-dot(normal,lightDir)),0.005);\n"
			"   for(int y=-1; y<=1;y++)\n"
			"   {\n"
			"       for(int x=-1; x<=1;x++)\n"
			"        {\n"
			"  				 float closeDepth = texture2D(sampler,(proj+vec3(float(x)*u_xPixelOffset,float(y)*u_yPixelOffset,0.05)).xy).x;\n "
			"                shadow += (closeDepth<(currentDepth-bias+bias*0.99))?0.5:1.0;\n"
			"         }\n"
			"    }\n"
			"   shadow /=16.0;\n"
			"   return shadow;\n"
			"}\n"
			"void main(void)\n"
			"{\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			" 	float shadow = 1.0;\n"
			"#ifdef FBO \n"
			"	 shadow = ShadowCalculate(u_sampler0,v_lightSpacePos);\n"
			"#endif \n"
			"float alpha = 1.0;\n"
			"if(shadow < 1.0 && shadow>0.62) alpha = 0.0;\n"
			"    FragColor = vec4(u_diffuse.rgb*shadow,u_diffuse.a *(1.0-shadow)*alpha);\n"
			"}\n"
			"\n";
	}

	const char * ShaderSrcCode::BlurVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in  vec3 a_position;\n"
			"in  vec2 a_texCoords;\n"
			"out  vec2 v_texCoords;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = vec4(a_position,1.0);\n"
			"    v_texCoords = a_texCoords;\n"
			"}\n"
			"\n"
			;
	}
	const char * ShaderSrcCode::BlurFrag()
	{
		return
			"#version 130 \n"
			"#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"in vec2 v_texCoords;\n"
			"const float v = 1.0/254.0;\n"
			" float weights[39] ; \n"
			"float samples[26] ;\n"
			"void main(void)\n"
			"{\n"
			" weights[0] = 0.250441;\n"
			" weights[1] = 0.437000;\n weights[2] =  0.635000;\n"
			" weights[3] =0.096356;\n weights[4] =0.064487;\n  weights[5] =0.039097;\n"
			" weights[6] =0.136575;\n weights[7] = 0.103222;\n weights[8] = 0.064912;\n"
			"weights[9] = 0.074844;\n  weights[10] =0.086388;\n weights[11] =0.062272;\n"
			" weights[12] =0.131798;\n  weights[13] =0.151695;\n weights[14] =0.103676;\n"
			" weights[15] = 0.035690;\n  weights[16] =0.042728;\n weights[17] =0.033003;\n"
			"  weights[18] =0.048593;\n  weights[19] =0.064740;\n  weights[20] =0.046131;\n"
			" weights[21] =0.048092;\n  weights[22] =0.003042;\n weights[23] =0.000400;\n"
			"weights[24] =0.028845;\n  weights[25] =0.005406;\n  weights[26] =0.001222;\n"
			"  weights[27] =0.031322;\n  weights[28] =0.006034;\n  weights[29] =0.001420;\n"
			" weights[30] =0.031428;\n weights[31] =0.009152;\n weights[32] =0.002511;\n"
			"  weights[33] =0.010936;\n weights[34] =0.002868;\n  weights[35] =0.000652;\n"
			" weights[36] =0.033588;\n weights[37] =0.023239;\n  weights[38] =0.009703;\n"
			" samples[0] =0.000000;\n  samples[1] =0.000000;\n"
			" samples[2] =1.633992;\n samples[3] =0.036795;\n"
			"  samples[4] =0.177801;\n  samples[5] =1.717593;\n"
			" samples[6] =-0.194986;\n  samples[7] =0.091894;\n"
			" samples[8] =-0.239737;\n  samples[9] =-0.220217;\n"
			"samples[10] =0.003530;\n  samples[11] =-0.118219;\n"
			" samples[12] =1.32010;\n  samples[13] =-0.181542;\n"
			"samples[14] =5.970690;\n  samples[15] =0.253378;\n"
			"samples[16] =-1.089250;\n samples[17] = 4.958349;\n"
			" samples[18] = -4.015465;\n samples[19] = 4.156699;\n"
			"samples[20] =-4.063099;\n  samples[21] =-4.110150;\n"
			" samples[22] =-0.638605;\n  samples[23] =-6.297663;\n"
			" samples[24] =2.542348;\n  samples[25] =-3.245901;\n"
			"    vec3 sum = vec3( 0.0 );\n"
			"    sum.r += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).r * weights[0];\n"
			"    sum.g += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).g * weights[1];\n"
			"    sum.b += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).b * weights[2];\n"
			"    for(int i = 1;i< 13 ;i++)\n"
			"    {\n"
			"        vec2 samplesTmp = vec2(samples[2*i],samples[2*i+1]);\n"
			"        vec3 weightsTmp = vec3(weights[3*i],weights[3*i+1],weights[3*i+2]);\n"
			"        float u_sampler1 = texture2D(u_sampler1, vec2( v_texCoords.s + samplesTmp.x * v, v_texCoords.t + samplesTmp.y * v ) ).r;\n"
			"        float dx = 1.0 - dFdx(u_sampler1);\n"
			"        float dy = 1.0 - dFdy(u_sampler1);\n"
			"        sum.r += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).r * weightsTmp.r;\n"
			"        sum.g += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).g * weightsTmp.g;\n"
			"        sum.b += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).b * weightsTmp.b;\n"
			"    }\n"
			"\n"
			"    FragColor = vec4(vec3(sum),1.0);\n"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::SpecularVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"out vec3 v_position;\n"
			"out vec3 v_normal;\n"
			"\n"
			"void main()\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    v_normal= normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"}\n";
	}
	const char * ShaderSrcCode::SpecularFrag()
	{
		return
			"#version 130 \n"
			"#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"in vec3 v_position;\n"
			"in vec3 v_normal;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_selectColor;\n"
			"uniform vec3 u_lightPosition;\n"
			"\n"
			"float beckmannDistribution(in float x, in float roughness)\n"
			"{\n"
			"    float NdotH = max(x, 0.0001);\n"
			"    float cos2Alpha = NdotH * NdotH;\n"
			"    float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n"
			"    float roughness2 = roughness * roughness;\n"
			"    float denom = 3.1415926 * roughness2 * cos2Alpha * cos2Alpha *0.05;\n"
			"    return exp(tan2Alpha / roughness2) / denom;\n"
			"}\n"
			"\n"
			"float cookTorranceSpecular(in vec3 lightDirection, in vec3 viewDirection, in vec3 surfaceNormal, in float roughness, in float fresnel)\n"
			"{\n"
			"    float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n"
			"    float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n"
			"    vec3 H = normalize(lightDirection + viewDirection);\n"
			"    float NdotH = max(dot(surfaceNormal, H), 0.0);\n"
			"    float VdotH = max(dot(viewDirection, H), 0.000001);\n"
			"    float LdotH = max(dot(lightDirection, H), 0.000001);\n"
			"    float G1 = (2.0 * NdotH * VdotN) / VdotH;\n"
			"    float G2 = (2.0 * NdotH * LdotN) / LdotH;\n"
			"    float G = min(1.0, min(G1, G2));\n"
			"    float D = beckmannDistribution(NdotH, roughness);\n"
			"    float F = fresnel;\n"
			"    return  G * F * D / (3.14159265 *max(VdotN, 0.000001)*max(LdotN, 0.000001));\n"
			"}\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip)\n"
			"    {\n"
			"       float dPara = u_clipPlane.w;\n"
			"        if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001)\n"
			"        {\n"
			"            discard;\n"
			"        }\n"
			"    }\n"
			"if(gl_FrontFacing)"
			"{"
			"    float specular = cookTorranceSpecular(normalize(u_lightPosition), -normalize(v_position), v_normal, 0.027, 0.04);\n"
			"    vec3 diff = vec3(max(dot(v_normal,normalize(u_lightPosition)),0.0));\n"
			"    FragColor = vec4(mix(u_ambient.xyz,vec3(diff)* u_diffuse.xyz*vec3(u_selectColor),0.95) + vec3(specular), u_diffuse.a);\n"
			"}"
			"else"
			"{"
			"    float specular = cookTorranceSpecular(normalize(u_lightPosition), -normalize(v_position),- v_normal, 0.027, 0.04);\n"
			"    vec3 diff = vec3(max(abs(dot(-v_normal,normalize(u_lightPosition))),0.0));\n"
			"    FragColor = vec4(mix(u_ambient.xyz,vec3(diff)* u_diffuse.xyz*vec3(u_selectColor),0.95) + vec3(specular), u_diffuse.a);\n"
			"}"
			"}\n"
			"\n";
	}


	const char * ShaderSrcCode::EdgeDetectionVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"out vec2 v_texCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::EdgeDetectionFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"in vec2 v_texCoords;\n"
			"void main( void )\n"
			"{\n"
			"float _Size = 1024.0;\n"
			"   vec3 lum = vec3(0.2125,0.7154,0.0721);\n"
			"     float mc00 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0*u_xPixelOffset,1.0*u_yPixelOffset)).rgb, lum);\n"
			"     float mc10 = dot(texture2D (u_sampler0, v_texCoords-vec2(0.0,1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc20 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc01 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0,0.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc11mc = dot(texture2D (u_sampler0, v_texCoords).rgb, lum);\n"
			"     float mc21 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,0.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc02 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc12 = dot(texture2D (u_sampler0, v_texCoords-vec2(0.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc22 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"\n"
			"     float GX = -1.0 * mc00 + mc20 + -2.0 * mc01 + 2.0 * mc21 - mc02 + mc22;\n"
			"     float GY = mc00 + 2.0 * mc10 + mc20 - mc02 - 2.0 * mc12 - mc22;\n"
			"     vec4 c;\n"
			"     float gratValue =length(vec2(GX,GY));\n "
			"     c = vec4(gratValue,gratValue,gratValue,1.0);\n"
			"\n"
			"      float factor = 1.0-c.x;\n"
			"      if(factor>0.92)\n"
			"      {\n"
			"      factor = 1.0;\n"
			"      }\n"
			"      else\n"
			"      {\n"
			"      factor = 0.0;\n"
			"      }\n"
			"   if(texture2D (u_sampler0, v_texCoords).a<0.33)"
			"{FragColor = vec4(factor,0.0,0.0,1.0);}\n"
			"else"
			"{ FragColor = vec4(factor,factor,factor,1.0);\n}"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::QuadVert()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"in  vec3 a_position;\n"
			"in  vec2 a_texCoords;\n"
			"out  vec2 v_texCoords;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = vec4(a_position,1.0);\n"
			"    v_texCoords = a_texCoords;\n"
			"}\n"
			"\n";
	}
	const char * ShaderSrcCode::QuadFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"uniform sampler2D u_sampler0;\n"
			"in vec2 v_texCoords;\n"
			"void main() { \n"
			"FragColor =texture2D(u_sampler0,v_texCoords);\n"
			"}\n";
	}
	const char * ShaderSrcCode::MultilightPerFragVert()
	{
		return

			"#version 130 \n"
			"precision highp float;\n"
			"in vec3 a_position;\n"
			"in vec3 a_normal;\n"
			"in vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_eyePosition;\n"
			"out vec3 v_position;\n"
			"out vec4 v_texCoords;\n"
			"out vec3 v_normal;\n"
			"out vec3 v_cubeTexCoords;\n"
			"out vec4 fvObjectPosition;\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"    v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"    v_texCoords = tempCoords;\n"
			"    v_normal= normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"    vec4 worldPos = u_modelMat * vec4(a_position,1.0);\n"
			"    vec3 worldPosT = worldPos.xyz;\n"
			"    v_cubeTexCoords =reflect(normalize(worldPosT -u_eyePosition), normalize(a_normal));\n"			
			" }\n"
			;
	}
	const char * ShaderSrcCode::MultilightPerFragFrag()
	{
		return
			"#version 130 \n"
			"precision highp float;\n"
			"out vec4 FragColor;\n"
			"struct Light\n"
			"{\n"
			"    vec4 ambient;\n"
			"    vec4 diffuse;\n"
			"    vec4 specular;\n"
			"    vec4 position;\n"
			"    vec3 intensity;\n"
			"    vec3 spotDirection;\n"
"    float spotExponent;\n"
"    float spotCutoff; // (range: [0.0,90.0], 180.0)\n"
"    float spotCosCutoff; // (range: [1.0,0.0],-1.0)\n"
"    float constant;\n"
"    float linear;\n"
"    float quadratic;\n"
"};\n"
"\n"
"struct LightModel\n"
"{\n"
"    vec4 ambient;    // Acs\n"
"};\n"
"\n"
"struct Materials\n"
"{\n"
"    vec4 emission;\n"
"    vec4 ambient;\n"
"    vec4 diffuse;\n"
"    vec4 specular;\n"
"    float shininess;\n"
"};\n"
"uniform LightModel u_lightModel ;\n"
"const int numberOfLights = 1;\n"
"uniform Light u_lights[1];\n"
"uniform int u_enbleLights[1];\n"
"uniform Materials u_materials;\n"
"uniform vec4 u_clipPlane;\n"
"uniform bool u_enableClip;\n"
"uniform bool u_useTex;\n"
"uniform bool u_useAmbientTex;\n"
"uniform bool u_useCubeMapTex;\n"
"uniform sampler2D u_sampler0;\n"
"uniform sampler2D u_sampler1;\n"
"uniform sampler2D u_sampler2;\n"
"uniform samplerCube u_samplerCube0;\n"
"uniform vec4 u_diffuse;\n"
"uniform vec4 u_selectColor;\n"
"in vec3 v_position;\n"
"in vec4 v_texCoords;\n"
"in vec3 v_normal;\n"
"in vec3 v_cubeTexCoords;\n"
"in vec4 fvObjectPosition;\n"
"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
"vec4 environment = vec4(1.0,1.0,1.0,1.0);\n"
"vec2 sphereMap(vec3 normal, vec3 ecPosition3)\n"
"{\n"
"   float m;\n"
"   vec3 r;\n"
"   vec3 u;\n"
"   u = normalize(ecPosition3);\n"
"   r = reflect(u, normal);\n"
"   m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0))+0.0001;\n"
"   return vec2 (r.x / m + 0.5, r.y / m + 0.5);\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"    vec3 totalAmbient= vec3(0.0,0.0,0.0);\n"
"    vec3 totalDiffuse = vec3(0.0,0.0,0.0);\n"
"    vec3 totalSpecular = vec3(0.0,0.0,0.0);\n"
"    vec3 lightDirection;\n"
"    float attenuation=1.0;\n"
"    vec3 testColor= vec3(0.7,0.0,0.0);"
"    vec3 totalLighting = vec3(u_materials.emission)+ vec3(u_lightModel.ambient) * vec3(u_materials.ambient);\n"
" vec3 diffuseColor;\n"
" vec3 specularColor;\n"
" vec3  vNormal ;\n"
"if(gl_FrontFacing){\n"
" vNormal         = normalize( v_normal );\n"
"}\n"
"else {\n"
" vNormal         = normalize( -v_normal );\n"
"}\n"
"    if(u_enableClip)\n"
"    {\n"
"       float dPara = u_clipPlane.w;\n"
"		float testvalue = (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
"        if( testvalue<0.0)\n"
"        {\n"
"            discard;\n"
"        }\n"
"    }\n"
"    if(u_useTex)\n"
"    {\n"
"        switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
"    }\n"
"    if(u_useAmbientTex)\n"
"    {\n"
"        vec2 sphereCoords = sphereMap(v_normal,v_position);\n"
"        environment = texture2D(u_sampler1,sphereCoords.xy);\n"
"    }\n"
"    if(u_useCubeMapTex)\n"
"    {\n"
"        environment = texture(u_samplerCube0,v_cubeTexCoords.xyz);\n"
"    }\n"
"    vec4 texColor = switchColor *environment;\n"
"    for(int index = 0;index<numberOfLights;index++)\n"
"    {\n"
"        if(u_enbleLights[index] == 1)\n"
"        {\n"

"            if (0.0 == u_lights[index].position.w) // directional light?\n"
"            {\n"

"                attenuation = 1.0; // no attenuation\n"
"                lightDirection = normalize(vec3(u_lights[index].position)/*- fvObjectPosition.xyz*/);\n"
"            }\n"
"        float fNDotL= clamp(abs(dot( vNormal, lightDirection )),0.2,1.0);\n"
"        vec3 diffuseReflection = attenuation\n"
"            * vec3(u_lights[index].diffuse) * vec3(u_materials.diffuse)\n"
"            * fNDotL;\n"
"         totalAmbient =vec3(totalAmbient) + vec3(u_lights[index].ambient) * vec3(u_materials.ambient);\n"
"		  float intensity = u_lights[index].intensity.x;\n"
"         totalDiffuse = totalDiffuse + diffuseReflection*intensity;\n"
"        vec3 eyeDirection =vec3(0,0,1); /*normalize(- fvObjectPosition.xyz );*/\n"
			"        vec3 halfVector = normalize(lightDirection+ eyeDirection);\n"
			"        float fNDotH = max(0.0, abs(dot(vNormal,halfVector)));\n"
			"        vec3 specularReflection = attenuation * vec3(u_lights[index].specular) * vec3(u_materials.specular)\n"
			"               * pow(fNDotH, u_materials.shininess);\n"
			"         totalSpecular = totalSpecular + specularReflection*intensity;\n"
			"        }\n"
			"    }\n"
			"    diffuseColor = min(totalLighting+totalAmbient+totalDiffuse,vec3(1.0));\n"
			"    specularColor= min(totalSpecular,vec3(1.0));\n"
			"    FragColor = vec4(vec3(texColor)*diffuseColor*vec3(u_selectColor)+vec3(specularColor),u_diffuse.a);\n"
			" }\n"
			;
	}
#else
	const char* ShaderSrcCode::BackgroundVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec4 a_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = a_color;\n"
			"}\n"
			;
	}

	const char* ShaderSrcCode::BackgroundFrag()
	{
		return
			"precision highp float;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_FragColor = v_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ModelBaseVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"attribute vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"varying vec3 v_viewDirection;\n"
			"varying vec3 v_lightDirection;\n"
			"varying vec3 v_normal;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3 v_position;\n"
			"void main() { \n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"v_texCoords = tempCoords;\n"
			"v_viewDirection  = normalize(u_eyePosition -fvObjectPosition.xyz);\n"
			"v_lightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			" v_normal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::ModelBaseFrag()
	{
		return
			"#extension GL_OES_standard_derivatives:enable \n"
			"precision highp float;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"uniform bool u_useTex;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"varying vec3 v_viewDirection;\n"
			"varying vec3 v_lightDirection;\n"
			"varying vec3 v_normal;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3 v_position;\n"
			"vec2 sphereMap(vec3 normal, vec3 ecPosition3){\n"
			"float m;\n"
			"vec3 r;\n vec3 u;\n"
			"u = normalize(ecPosition3);\n"
			"r = reflect(u, normal);\n"
			"m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0))+0.0001;\n"
			"return vec2 (r.x / m + 0.5, r.y / m + 0.5);\n"
			"}\n"
			"const vec4 ambientColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const vec4 diffuseColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const float shiness = 30.0;\n"
			"const vec4 specularColor = vec4(0.5,0.5,0.5,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"void main() { \n"
			"float fNDotL =0.0;\n"
			"vec3 	halfvector;\n"
			"float fNDotH;"
			" vec3  fvNormal ;\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"if(gl_FrontFacing){\n"
			" fvNormal         = normalize( v_normal );\n"
			"}\n"
			"else {\n"
			" fvNormal         = normalize( -v_normal );\n"
			"}\n"
			"vec2 sphereCoords = sphereMap(fvNormal,v_position);\n"
			"//switchColor = switchColor * texture2D(u_sampler1,sphereCoords.xy);\n"
			" fNDotL           = clamp(dot( fvNormal, v_lightDirection ),0.001,1.0);\n"
			"halfvector        =normalize(v_lightDirection+ v_viewDirection );\n"
			" fNDotH            = dot(fvNormal,halfvector);\n"
			"if(u_useTex){\n"
			"switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"}\n"
			"vec4  fvTotalAmbient   = u_ambient * ambientColor;\n"
			"vec4  fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor; \n"
			"vec4  fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), shiness ) );\n"
			"vec4 colorLinear = fvTotalAmbient + fvTotalDiffuse + fvTotalSpecular;\n"
			"gl_FragColor = vec4(colorLinear.xyz,u_diffuse.a);\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::EdgeVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec3 v_position;\n"
			"#ifdef DEPTH_EDGE\n"
			"varying vec4 v_projectPos;\n"
			"#endif\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"#ifdef DEPTH_EDGE\n"
			"v_projectPos = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"#endif\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"gl_PointSize = 3.0;\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::EdgeFrag()
	{
		return
			"precision highp float;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"#ifdef DEPTH_EDGE\n"
			"uniform sampler2D u_sampler0;\n"
			"varying vec4 v_projectPos;\n"
			"#endif\n"
			"varying vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"float testvalue = (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
			"if( testvalue<0.0)\n"
			"  {\n"
			" discard;\n"
			"}\n"
			"}\n"
			"#ifdef DEPTH_EDGE\n"
			"vec3 proj =v_projectPos.xyz/v_projectPos.w;\n "
			"   proj = proj *0.5+0.5;\n"
			"float priDepth = texture2D(u_sampler0,proj.xy).x;\n"
			"if(priDepth<proj.z) discard;\n"
			"#endif\n"
			"gl_FragColor = u_diffuse;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::WireframeVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec3 v_center;\n"
			"void main(){\n"
			"v_center = a_normal;\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"}\n"
			;
	}
	const char * ShaderSrcCode::WireframeFrag()
	{
		return
			"#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"uniform vec4 u_diffuse;\n"
			"varying vec3 v_center;\n"
			"float edgeFactorTri() {\n"
			"vec3 d = fwidth( v_center.xyz );\n"
			"vec3 a3 = smoothstep( vec3( 0.0 ), d * 1.5, v_center.xyz );\n"
			"return min( min( a3.x, a3.y ), a3.z );\n"
			"}\n"
			"void main() { \n"
			"gl_FragColor.rgb = mix( vec3( 1.0 ), vec3( 0.2 ), edgeFactorTri() );\n"
			"gl_FragColor.a = 1.0;\n"
			"}\n"
			;
	}


	const char* ShaderSrcCode::BrdfVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"attribute vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"varying vec3 v_viewDirection;\n"
			"varying vec3 v_lightDirection;\n"
			"varying vec3 v_normal;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3    v_position;"
			"varying vec4 v_worldPosition;\n"
			"void main() { \n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 v_worldPosition = u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_texCoords = tempCoords;\n"
			"v_position = fvObjectPosition.xyz;\n"
			"v_viewDirection  = normalize( -fvObjectPosition.xyz);\n"
			"v_lightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			" v_normal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"}\n"
			;
	}

	const char* ShaderSrcCode::BrdfFrag()
	{
		return "#extension GL_OES_standard_derivatives:enable \n"
			"precision highp float;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform bool u_useTex;\n"
			"uniform float u_fresnel0;\n"
			"uniform float u_roughness;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"varying vec3 v_viewDirection;\n"
			"varying vec3 v_lightDirection;\n"
			"varying vec3 v_normal;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3    v_position;"
			"varying vec4 v_worldPosition;\n"
			"const vec3 ambientColor = vec3(1.0, 1.0, 1.0);\n"
			"const vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n"
			"const float shiness = 65.0;\n"
			"const vec4 specularColor = vec4(0.5,0.5,0.5,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"float fresnel(float f0, vec3 n, vec3 l){\n"
			"return f0 + (1.0-f0) * pow(1.0- dot(n, l), 5.0);\n"
			"}\n"
			"float distribution(vec3 n, vec3 h, float roughness){\n"
			"float m_Sq= roughness * roughness;\n"
			"float NdotH_Sq= max(dot(n, h), 0.01);\n"
			"NdotH_Sq= NdotH_Sq * NdotH_Sq;\n"
			"return exp( (NdotH_Sq - 1.0)/(m_Sq*NdotH_Sq) )/ (3.14159265 * m_Sq * NdotH_Sq * NdotH_Sq) ;\n"
			"}\n"
			"float geometry(vec3 n, vec3 h, vec3 v, vec3 l, float roughness){\n"
			"float NdotH= dot(n, h);\n"
			"float NdotL= dot(n, l);\n"
			"float NdotV= dot(n, v);\n"
			"float VdotH= dot(v, h);\n"
			"float NdotL_clamped= max(NdotL, 0.01);\n"
			"float NdotV_clamped= max(NdotV, 0.01);\n"
			"return min( min( 2.0 * NdotH * NdotV_clamped / VdotH, 2.0 * NdotH * NdotL_clamped / VdotH), 1.0);\n"
			"}\n"
			"float diffuseEnergyRatio(float f0, vec3 n, vec3 l){\n"
			" return 1.0 - fresnel(f0, n, l);\n"
			"  }\n"
			"void main() { \n"
			"vec3  fvLightDirection;\n"
			" vec3  fvNormal ;\n"
			" vec3 normal;\n "
			"vec3 view;\n"
			" vec3 halfVec;\n"
			"float NdotL;\n"
			"float NdotV;\n"
			"float NdotL_clamped;\n"
			"float NdotV_clamped;\n"
			"float brdf_spec;\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"if(gl_FrontFacing){\n"
			" fvNormal         = normalize( v_normal );\n"
			"}\n"
			"else {\n"
			" fvNormal         = normalize( -v_normal );\n"
			"}\n"
			"fvLightDirection = normalize( v_lightDirection );\n"
			" normal =  normalize(fvNormal);\n"
			"view   = normalize(v_viewDirection);\n"
			" halfVec=  normalize(fvLightDirection + view);\n"
			"NdotL= dot(normal, fvLightDirection);\n"
			"NdotV= dot(normal, view);\n"
			"NdotL_clamped= max(NdotL, 0.01);\n"
			"NdotV_clamped= max(NdotV, 0.01);\n"
			"brdf_spec= fresnel(u_fresnel0, halfVec, fvLightDirection) * \n"
			" geometry(normal, halfVec, view, fvLightDirection, u_roughness) * \n"
			"distribution(normal, halfVec, u_roughness) / (4.0 * NdotL_clamped * NdotV_clamped);\n"
			"if(u_useTex){\n"
			"switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"}\n"
			"vec3 color_spec = NdotL_clamped * brdf_spec * diffuseColor;\n"
			"vec3 color_diff = switchColor.xyz*NdotL_clamped * diffuseEnergyRatio(u_fresnel0, normal, fvLightDirection) * vec3(u_diffuse.xyz) * diffuseColor;\n"
			" gl_FragColor = vec4( color_diff + color_spec, u_diffuse.a)  ; \n"
			"}\n";
	}

	const char * ShaderSrcCode::AxisVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"uniform vec4 u_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = u_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::AxisFrag()
	{
		return
			"precision highp float;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_FragColor = v_color;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ImageVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec2 v_texCoords;\n"
			"varying vec3 v_position;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ImageFrag()
	{
		return
			"precision highp float;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"varying vec2 v_texCoords;\n"
			"varying vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"vec4 pcolor = texture2D(u_sampler0,v_texCoords);\n"
			"vec4 tcolor = pcolor*u_diffuse;\n"
			"gl_FragColor = vec4(tcolor.xyz,pcolor.a);\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::CubeMapVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec3 v_cubeTexCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_cubeTexCoords = a_position;\n"
			"}\n";
	}
	const char * ShaderSrcCode::CubeMapFrag()
	{
		return
			"precision highp float;\n"
			"uniform samplerCube u_samplerCube0;\n"
			"varying vec3 v_cubeTexCoords;\n"
			"void main() { \n"
			"vec4 pcolor = textureCube(u_samplerCube0,v_cubeTexCoords);\n"
			"gl_FragColor = pcolor;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::ClipPlaneVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"uniform vec4 u_color;\n"
			"uniform mat4 u_MVPMat;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_Position = u_MVPMat * vec4(a_position,1.0);\n"
			"v_color = u_color;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ClipPlaneFrag()
	{
		return "precision highp float;\n"
			"varying vec4 v_color;\n"
			"void main() { \n"
			"gl_FragColor = v_color;\n"
			"}\n";
	}

	const char * ShaderSrcCode::MultilightVert()
	{
		return "precision highp float;\n"
			"//#define FBO \n"
			"struct Light\n"
			"{\n"
			"    vec4 ambient;\n"
			"    vec4 diffuse;\n"
			"    vec4 specular;\n"
			"    vec4 position;\n"
			"    vec3 intensity;\n"
			"    vec3 spotDirection;\n"
			"    float spotExponent;\n"
			"    float spotCutoff; // (range: [0.0,90.0], 180.0)\n"
			"    float spotCosCutoff; // (range: [1.0,0.0],-1.0)\n"
			"    float constant;\n"
			"    float linear;\n"
			"    float quadratic;\n"
			"};\n"
			"\n"
			"struct LightModel\n"
			"{\n"
			"    vec4 ambient;    // Acs\n"
			"};\n"
			"\n"
			"struct Materials\n"
			"{\n"
			"    vec4 emission;\n"
			"    vec4 ambient;\n"
			"    vec4 diffuse;\n"
			"    vec4 specular;\n"
			"    float shininess;\n"
			"};\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"attribute vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"#ifdef FBO \n"
			"uniform mat4 u_lightMat;\n"
			"uniform mat4 u_lightProject;\n"
			"#endif \n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_eyePosition;\n"
			"\n"
			"//varying\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3 v_diffuseColor;\n"
			"varying vec3 v_specularColor;\n"
			"varying vec3 v_diffuseColorN;\n"
			"varying vec3 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"varying vec3 v_cubeTexCoords;\n"
			"#ifdef FBO \n"
			"varying vec4 v_lightSpacePos;\n"
			"varying vec3 v_worldNormal;\n"
			"varying vec3 v_worldPos;\n"
			"uniform vec3 u_shadowLPos;\n"
			"#endif \n"
			"//scene ambient\n"
			"uniform LightModel u_lightModel ;\n"
			"const int numberOfLights = 1;\n"
			"uniform Light u_lights[1];\n"
			"uniform int u_enbleLights[1];\n"
			"//Materials\n"
			"uniform Materials u_materials;\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    vec3 lightDirection;\n"
			"    float attenuation=1.0;\n"
			"    vec3 totalLighting = vec3(u_materials.emission)+ vec3(u_lightModel.ambient) * vec3(u_materials.ambient);\n"
			"    vec3 totalAmbient= vec3(0.0,0.0,0.0);\n"
			"    vec3 totalDiffuse = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalSpecular = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalAmbientBack= vec3(0.0,0.0,0.0);\n"
			"    vec3 totalDiffuseBack = vec3(0.0,0.0,0.0);\n"
			"    vec3 totalSpecularBack = vec3(0.0,0.0,0.0);\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"#ifdef FBO \n"
			"    v_lightSpacePos = u_lightProject*u_lightMat *u_modelMat* vec4(a_position,1.0);\n"
			"    v_worldNormal = a_normal;\n"
			"#endif \n"
			"    vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"    v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"    v_texCoords = tempCoords;\n"
			"    vec3 vNormal= normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"    v_normal = vNormal;\n"
			"    vec4 worldPos = u_modelMat * vec4(a_position,1.0);\n"
			"    vec3 worldPosT = worldPos.xyz;\n"
			"    v_cubeTexCoords =reflect(normalize(worldPosT -u_eyePosition), normalize(a_normal));\n"
			"#ifdef FBO\n"
			"   v_worldPos = worldPosT;\n"
			"#endif\n"
			"    for(int index = 0;index<numberOfLights;index++)\n"
			"    {\n"
			"        if(u_enbleLights[index] == 1)\n"
			"        {\n"
			"\n"
			"            if (0.0 == u_lights[index].position.w) // directional light?\n"
			"            {\n"
			"                attenuation = 1.0; // no attenuation\n"
			"                lightDirection = normalize(vec3(u_lights[index].position));\n"
			"            }\n"
			"            else // point light or spotlight (or other kind of light)\n"
			"            {\n"
			"                vec3 positionToLightSource = vec3(u_lights[index].position) - fvObjectPosition.xyz ;\n"
			"                float distance = length(positionToLightSource);\n"
			"                lightDirection = normalize(positionToLightSource);\n"
			"                float tempA= u_lights[index].constant + u_lights[index].linear * distance + u_lights[index].quadratic * distance * distance;\n"
			"                attenuation = 1.0 / tempA;\n"
			"                if (u_lights[index].spotCutoff <= 90.0) // spotlight?\n"
			"                {\n"
			"                    float clampedCosine = max(0.0001, dot(lightDirection, -normalize(u_lights[index].spotDirection)));\n"
			"                    if (clampedCosine < u_lights[index].spotCosCutoff) // outside of spotlight cone?\n"
			"                    {\n"
			"                        attenuation = 0.0;\n"
			"                    }\n"
			"                    else\n"
			"                    {\n"
			"                        attenuation = attenuation * pow(clampedCosine, u_lights[index].spotExponent);\n"
			"//attenuation *= clamp((clampedCosine-cos(radians(15.0)) ) / (cos(radians(10.0)) - cos(radians(15.0))), 0.0, 1.0);\n"
			"                    }\n"
			"                }\n"
			"            }\n"
			"\n"
			"         //a side\n"
			"        float fNDotL= clamp(abs(dot( vNormal, lightDirection )),0.3,1.0);\n"
			"        vec3 diffuseReflection = attenuation\n"
			"            * vec3(u_lights[index].diffuse) * vec3(u_materials.diffuse)\n"
			"            * fNDotL;\n"
			"        //the othor\n"
			"        fNDotL= clamp(abs(dot( -vNormal, lightDirection )),0.3,1.0);\n"
			"        vec3 diffuseReflectionBack = attenuation\n"
			"            * vec3(u_lights[index].diffuse) * vec3(u_materials.diffuse)\n"
			"            * fNDotL;\n"
			"\n"
			"         totalAmbient =vec3(totalAmbient) + vec3(u_lights[index].ambient) * vec3(u_materials.ambient);\n"
			"		  float intensity = u_lights[index].intensity.x;\n"
			"         totalDiffuse = totalDiffuse + diffuseReflection*intensity;\n"
			"         totalDiffuseBack = totalDiffuseBack + diffuseReflectionBack*intensity;\n"
			"\n"
			"        vec3 eyeDirection = normalize(- fvObjectPosition.xyz );\n"
			"        vec3 halfVector = normalize(lightDirection+ eyeDirection);\n"
			"\n"
			"		vec3 tempsp = vec3(u_lights[index].specular);\n"
			"		float spv =  tempsp.x*tempsp.x+tempsp.y*tempsp.y+tempsp.z*tempsp.z;\n"
			"			if(spv>0.0){\n"
			"        //a side\n"
			"        float fNDotH = max(0.0, abs(dot(vNormal,halfVector)));\n"
			"        vec3 specularReflection = attenuation * vec3(u_lights[index].specular) * vec3(u_materials.specular)\n"
			"               * pow(fNDotH, u_materials.shininess);\n"
			"        //the other\n"
			"        fNDotH = max(0.0, abs(dot(-vNormal,halfVector)));\n"
			"        vec3 specularReflectionBack = attenuation * vec3(u_lights[index].specular) * vec3(u_materials.specular)\n"
			"               * pow(fNDotH, u_materials.shininess);\n"
			"\n"
			"         totalSpecular = totalSpecular + specularReflection*intensity;\n"
			"         totalSpecularBack = totalSpecularBack + specularReflectionBack*intensity;\n"
			"			}\n"
			"        }\n"
			"    }\n"
			"    v_diffuseColor = min(totalLighting+totalAmbient+totalDiffuse,vec3(1.0));\n"
			"    v_specularColor = min(totalSpecular,vec3(1.0));\n"
			"\n"
			"    v_diffuseColorN = min(totalLighting+totalAmbient+totalDiffuseBack,vec3(1.0));\n"
			"    v_specularColorN = min(totalSpecularBack,vec3(1.0));\n"
			" }\n"

			;
	}
	const char * ShaderSrcCode::MultilightFrag()
	{
		return "precision highp float;\n"
			"//#define FBO \n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform bool u_useTex;\n"
			"uniform bool u_useAmbientTex;\n"
			"uniform bool u_useCubeMapTex;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"uniform sampler2D u_sampler2;\n"
			"uniform samplerCube u_samplerCube0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_selectColor;\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec3 v_diffuseColor;\n"
			"varying vec3 v_specularColor;\n"
			"varying vec3 v_diffuseColorN;\n"
			"varying vec3 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"varying vec3 v_cubeTexCoords;\n"
			"#ifdef FBO \n"
			"varying vec4 v_lightSpacePos;\n"
			"varying vec3 v_worldNormal;\n"
			"varying vec3 v_worldPos;\n"
			"uniform vec3 u_shadowLPos;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"#endif \n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 environment = vec4(1.0);\n"
			"#ifdef FBO \n"
			"float ShadowCalculate(sampler2D sampler,vec4 fragPosLightSpace)\n"
			"{\n"
			"   float shadow = 1.0;\n"
			"	vec3 proj =fragPosLightSpace.xyz/fragPosLightSpace.w;\n"
			"   proj = proj *0.5+0.5;\n"
			"   float currentDepth = proj.z;\n"
			"   vec3 normal = normalize(v_worldNormal);\n"
			"   vec3 lightDir = normalize(u_shadowLPos-v_worldPos);\n"
			"   float bias = max(0.05*(1.0-dot(normal,lightDir)),0.005);\n"
			"   for(int y=-1; y<=1;y++)\n"
			"   {\n"
			"       for(int x=-1; x<=1;x++)\n"
			"        {\n"
			"  				 float closeDepth = texture2D(sampler,(proj+vec3(float(x)*u_xPixelOffset,float(y)*u_yPixelOffset,0.05)).xy).x;\n "
			"                shadow += (closeDepth<(currentDepth-bias))?0.5:1.0;\n"
			"         }\n"
			"    }\n"
			"   shadow /=16.0;\n"
			"   shadow += 0.2;\n"
			"   return shadow;\n"
			"}\n"
			"#endif \n"
			"vec2 sphereMap(vec3 normal, vec3 ecPosition3)\n"
			"{\n"
			"   float m;\n"
			"   vec3 r;\n"
			"   vec3 u;\n"
			"   u = normalize(ecPosition3);\n"
			"   r = reflect(u, normal);\n"
			"   m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0))+0.0001;\n"
			"   return vec2 (r.x / m + 0.5, r.y / m + 0.5);\n"
			"}\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip)\n"
			"    {\n"
			"       float dPara = u_clipPlane.w;\n"
			"		float testvalue = (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
			"        if( testvalue<0.0)\n"
			"        {\n"
			"            discard;\n"
			"        }\n"
			"    }\n"
			"    if(u_useTex)\n"
			"    {\n"
			"        switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"    }\n"
			"    if(u_useAmbientTex)\n"
			"    {\n"
			"        vec2 sphereCoords = sphereMap(v_normal,v_position);\n"
			"        environment = texture2D(u_sampler1,sphereCoords.xy);\n"
			"    }\n"
			"    if(u_useCubeMapTex)\n"
			"    {\n"
			"        environment = textureCube(u_samplerCube0,v_cubeTexCoords.xyz);\n"
			"    }\n"
			"    vec4 texColor = switchColor *environment;\n"
			" 	float shadow = 1.0;\n"
			"#ifdef FBO \n"
			"	 shadow = ShadowCalculate(u_sampler2,v_lightSpacePos);\n"
			"#endif \n"
			"	float alpha = u_diffuse.a;\n"
			"   if(u_selectColor.y < 0.8)"
			"{\n"
			"	alpha = 0.3;\n"
			"}\n"
			"    if(gl_FrontFacing)\n"
			"    {\n"
			"        gl_FragColor = vec4(vec3(texColor)*v_diffuseColor*(shadow)*vec3(u_selectColor)+vec3(v_specularColor)*(shadow),alpha);\n"
			"    }\n"
			"    else\n"
			"    {\n"
			"        gl_FragColor = vec4(vec3(texColor)*v_diffuseColorN*(shadow)*vec3(u_selectColor)+vec3(v_specularColorN)*(shadow),alpha);\n"
			"    }\n"
			"}\n"
			"\n"

			;
	}

	const char * ShaderSrcCode::BaseVertexVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"attribute vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"vec3 vviewDirection;\n"
			"vec3 vlightDirection;\n"
			"vec3 vnormal;\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec4 v_diffuseColor;\n"
			"varying vec4 v_specularColor;\n"
			"varying vec4 v_diffuseColorN;\n"
			"varying vec4 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"const vec4 ambientColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const vec4 diffuseColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"uniform float u_shininess;\n"
			"const vec4 specularColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"void main() {\n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"v_texCoords = tempCoords;\n"
			"vviewDirection  = normalize( -fvObjectPosition.xyz);\n"
			"vlightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			"vnormal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"v_normal = vnormal;\n"
			"float fNDotL =0.0;\n"
			"vec3 halfvector;\n"
			"float fNDotH;\n"
			"fNDotL           = clamp(abs(dot( vnormal, vlightDirection )),0.3,1.0);\n"
			"halfvector        =normalize(vlightDirection+ vviewDirection );\n"
			"fNDotH            = dot(vnormal,halfvector);\n"
			"vec4  fvTotalAmbient   = u_ambient * ambientColor;\n"
			"vec4  fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"vec4  fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColor=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColor = min(fvTotalSpecular,vec4(1.0));\n"
			"\n"
			"fNDotL           = clamp(abs(dot( -vnormal, vlightDirection )),0.3,1.0);\n"
			"fNDotH            = dot(-vnormal,halfvector);\n"
			"fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColorN=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColorN = min(fvTotalSpecular,vec4(1.0));\n"
			""
			"}\n"
			"\n"


			;
	}
	const char * ShaderSrcCode::BaseVertexFrag()
	{
		return
			"precision highp float;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform bool u_useTex;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_selectColor;\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec4 v_diffuseColor;\n"
			"varying vec4 v_specularColor;\n"
			"varying vec4 v_diffuseColorN;\n"
			"varying vec4 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 environment = vec4(1.0);\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip){\n"
			"        float dPara = u_clipPlane.w;\n"
			"        if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"                    discard;\n"
			"            }\n"
			"    }\n"
			"    if(u_useTex){\n"
			"          switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"                }\n"
			"	vec4 texColor = switchColor *environment;\n"
			"    if(gl_FrontFacing){\n"
			"    	  gl_FragColor = vec4(vec3(texColor*v_diffuseColor)*vec3(u_selectColor)+vec3(v_specularColor),u_diffuse.a+1.0);\n"
			"    }else{\n"
			"         gl_FragColor = vec4(vec3(texColor*v_diffuseColorN)*vec3(u_selectColor)+vec3(v_specularColorN),u_diffuse.a+1.0);\n"
			"    }\n"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::ShadowMapVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec3 v_position;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"}\n";
	}
	const char * ShaderSrcCode::ShadowMapFrag()
	{
		return
			"precision highp float;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"varying vec3 v_position;\n"
			"void main() { \n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			"gl_FragColor = vec4(gl_FragCoord.z,gl_FragCoord.z,gl_FragCoord.z,1.0);\n"
			"}\n"
			;
	}


	const char * ShaderSrcCode::FBODebugVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec2 v_texCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::FBODebugFrag()
	{
		return
			"precision highp float;\n"
			"uniform sampler2D u_sampler0;\n"
			"varying vec2 v_texCoords;\n"
			"varying vec3 v_position;\n"
			"void main() { \n"
			"vec4 pcolor = texture2D(u_sampler0,v_texCoords);\n"
			"vec4 tcolor = pcolor;\n"
			"gl_FragColor = tcolor;\n"
			"}\n"
			;
	}

	const char * ShaderSrcCode::PlaneShadowVert()
	{
		return
			"precision highp float;\n"
			"#define FBO \n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"#ifdef FBO \n"
			"uniform mat4 u_lightMat;\n"
			"uniform mat4 u_lightProject;\n"
			"#endif \n"
			"\n"
			"varying vec3 v_position;\n"
			"#ifdef FBO \n"
			"varying vec4 v_lightSpacePos;\n"
			"varying vec3 v_worldNormal;\n"
			"varying vec3 v_worldPos;\n"
			"#endif \n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    vec3 lightDirection;\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"v_position = fvObjectPosition.xyz;\n"
			"#ifdef FBO \n"
			"    v_lightSpacePos = u_lightProject*u_lightMat *u_modelMat* vec4(a_position,1.0);\n"
			"    v_worldNormal = a_normal;\n"
			"#endif \n"
			"    vec4 worldPos = u_modelMat * vec4(a_position,1.0);\n"
			"    v_worldPos = worldPos.xyz;\n"
			" }\n";
	}
	const char * ShaderSrcCode::PlaneShadowFrag()
	{
		return
			"precision highp float;\n"
			"#define FBO \n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"varying vec3 v_position;\n"
			"#ifdef FBO \n"
			"varying vec4 v_lightSpacePos;\n"
			"varying vec3 v_worldNormal;\n"
			"varying vec3 v_worldPos;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform vec3 u_shadowLPos;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"#endif \n"
			"float ShadowCalculate(sampler2D sampler,vec4 fragPosLightSpace)\n"
			"{\n"
			"   float shadow = 1.0;\n"
			"	vec3 proj =fragPosLightSpace.xyz/fragPosLightSpace.w;\n"
			"   proj = proj *0.5+0.5;\n"
			"  if(proj.x>1.0 || proj.x<0.0 || proj.y>1.0 || proj.y<0.0) return 1.0;\n"
			"   float currentDepth = proj.z;\n"
			"   vec3 normal = normalize(v_worldNormal);\n"
			"   vec3 lightDir = normalize(u_shadowLPos-v_worldPos);\n"
			"   float bias = max(0.05*(1.0-dot(normal,lightDir)),0.005);\n"
			"   for(int y=-1; y<=1;y++)\n"
			"   {\n"
			"       for(int x=-1; x<=1;x++)\n"
			"        {\n"
			"  				 float closeDepth = texture2D(sampler,(proj+vec3(float(x)*u_xPixelOffset,float(y)*u_yPixelOffset,0.05)).xy).x;\n "
			"                shadow += (closeDepth<(currentDepth-bias+bias*0.99))?0.5:1.0;\n"
			"         }\n"
			"    }\n"
			"   shadow /=16.0;\n"
			"   return shadow;\n"
			"}\n"
			"void main(void)\n"
			"{\n"
			"if(u_enableClip){\n"
			"float dPara = u_clipPlane.w;\n"
			"if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"discard;\n"
			"}\n"
			"}\n"
			" 	float shadow = 1.0;\n"
			"#ifdef FBO \n"
			"	 shadow = ShadowCalculate(u_sampler0,v_lightSpacePos);\n"
			"#endif \n"
			"float alpha = 1.0;\n"
			"if(shadow < 1.0 && shadow>0.62) alpha = 0.0;\n"
			"    gl_FragColor = vec4(u_diffuse.rgb*shadow,u_diffuse.a *(1.0-shadow)*alpha);\n"
			"}\n"
			"\n";
	}

	const char * ShaderSrcCode::BlurVert()
	{
		return
			"precision highp float;\n"
			"attribute  vec3 a_position;\n"
			"attribute  vec2 a_texCoords;\n"
			"varying  vec2 v_texCoords;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = vec4(a_position,1.0);\n"
			"    v_texCoords = a_texCoords;\n"
			"}\n"
			"\n"
			;
	}
	const char * ShaderSrcCode::BlurFrag()
	{
		return
			"#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform sampler2D u_sampler1;\n"
			"varying vec2 v_texCoords;\n"
			"const float v = 1.0/254.0;\n"
			" float weights[39] ; \n"
			"float samples[26] ;\n"
			"void main(void)\n"
			"{\n"
			" weights[0] = 0.250441;\n"
			" weights[1] = 0.437000;\n weights[2] =  0.635000;\n"
			" weights[3] =0.096356;\n weights[4] =0.064487;\n  weights[5] =0.039097;\n"
			" weights[6] =0.136575;\n weights[7] = 0.103222;\n weights[8] = 0.064912;\n"
			"weights[9] = 0.074844;\n  weights[10] =0.086388;\n weights[11] =0.062272;\n"
			" weights[12] =0.131798;\n  weights[13] =0.151695;\n weights[14] =0.103676;\n"
			" weights[15] = 0.035690;\n  weights[16] =0.042728;\n weights[17] =0.033003;\n"
			"  weights[18] =0.048593;\n  weights[19] =0.064740;\n  weights[20] =0.046131;\n"
			" weights[21] =0.048092;\n  weights[22] =0.003042;\n weights[23] =0.000400;\n"
			"weights[24] =0.028845;\n  weights[25] =0.005406;\n  weights[26] =0.001222;\n"
			"  weights[27] =0.031322;\n  weights[28] =0.006034;\n  weights[29] =0.001420;\n"
			" weights[30] =0.031428;\n weights[31] =0.009152;\n weights[32] =0.002511;\n"
			"  weights[33] =0.010936;\n weights[34] =0.002868;\n  weights[35] =0.000652;\n"
			" weights[36] =0.033588;\n weights[37] =0.023239;\n  weights[38] =0.009703;\n"
			" samples[0] =0.000000;\n  samples[1] =0.000000;\n"
			" samples[2] =1.633992;\n samples[3] =0.036795;\n"
			"  samples[4] =0.177801;\n  samples[5] =1.717593;\n"
			" samples[6] =-0.194986;\n  samples[7] =0.091894;\n"
			" samples[8] =-0.239737;\n  samples[9] =-0.220217;\n"
			"samples[10] =0.003530;\n  samples[11] =-0.118219;\n"
			" samples[12] =1.32010;\n  samples[13] =-0.181542;\n"
			"samples[14] =5.970690;\n  samples[15] =0.253378;\n"
			"samples[16] =-1.089250;\n samples[17] = 4.958349;\n"
			" samples[18] = -4.015465;\n samples[19] = 4.156699;\n"
			"samples[20] =-4.063099;\n  samples[21] =-4.110150;\n"
			" samples[22] =-0.638605;\n  samples[23] =-6.297663;\n"
			" samples[24] =2.542348;\n  samples[25] =-3.245901;\n"
			"    vec3 sum = vec3( 0.0 );\n"
			"    sum.r += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).r * weights[0];\n"
			"    sum.g += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).g * weights[1];\n"
			"    sum.b += texture2D( u_sampler0, vec2( v_texCoords.s + samples[0] * v, v_texCoords.t + samples[1] * v ) ).b * weights[2];\n"
			"    for(int i = 1;i< 13 ;i++)\n"
			"    {\n"
			"        vec2 samplesTmp = vec2(samples[2*i],samples[2*i+1]);\n"
			"        vec3 weightsTmp = vec3(weights[3*i],weights[3*i+1],weights[3*i+2]);\n"
			"        float u_sampler1 = texture2D(u_sampler1, vec2( v_texCoords.s + samplesTmp.x * v, v_texCoords.t + samplesTmp.y * v ) ).r;\n"
			"        float dx = 1.0 - dFdx(u_sampler1);\n"
			"        float dy = 1.0 - dFdy(u_sampler1);\n"
			"        sum.r += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).r * weightsTmp.r;\n"
			"        sum.g += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).g * weightsTmp.g;\n"
			"        sum.b += texture2D( u_sampler0, vec2( v_texCoords.s + samplesTmp.x * v * dx, v_texCoords.t + samplesTmp.y * v * dy ) ).b * weightsTmp.b;\n"
			"    }\n"
			"\n"
			"    gl_FragColor = vec4(vec3(sum),1.0);\n"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::SpecularVert()
	{
		return
			"precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"varying vec3 v_position;\n"
			"varying vec3 v_normal;\n"
			"\n"
			"void main()\n"
			"{\n"
			"    gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    v_normal= normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"    vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"    v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"}\n";
	}
	const char * ShaderSrcCode::SpecularFrag()
	{
		return "#extension GL_OES_standard_derivatives : enable\n"
			"precision highp float;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"varying vec3 v_position;\n"
			"varying vec3 v_normal;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_selectColor;\n"
			"uniform vec3 u_lightPosition;\n"
			"\n"
			"float beckmannDistribution(in float x, in float roughness)\n"
			"{\n"
			"    float NdotH = max(x, 0.0001);\n"
			"    float cos2Alpha = NdotH * NdotH;\n"
			"    float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n"
			"    float roughness2 = roughness * roughness;\n"
			"    float denom = 3.1415926 * roughness2 * cos2Alpha * cos2Alpha *0.05;\n"
			"    return exp(tan2Alpha / roughness2) / denom;\n"
			"}\n"
			"\n"
			"float cookTorranceSpecular(in vec3 lightDirection, in vec3 viewDirection, in vec3 surfaceNormal, in float roughness, in float fresnel)\n"
			"{\n"
			"    float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n"
			"    float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n"
			"    vec3 H = normalize(lightDirection + viewDirection);\n"
			"    float NdotH = max(dot(surfaceNormal, H), 0.0);\n"
			"    float VdotH = max(dot(viewDirection, H), 0.000001);\n"
			"    float LdotH = max(dot(lightDirection, H), 0.000001);\n"
			"    float G1 = (2.0 * NdotH * VdotN) / VdotH;\n"
			"    float G2 = (2.0 * NdotH * LdotN) / LdotH;\n"
			"    float G = min(1.0, min(G1, G2));\n"
			"    float D = beckmannDistribution(NdotH, roughness);\n"
			"    float F = fresnel;\n"
			"    return  G * F * D / (3.14159265 *max(VdotN, 0.000001)*max(LdotN, 0.000001));\n"
			"}\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip)\n"
			"    {\n"
			"       float dPara = u_clipPlane.w;\n"
			"        if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001)\n"
			"        {\n"
			"            discard;\n"
			"        }\n"
			"    }\n"
			"if(gl_FrontFacing)"
			"{"
			"    float specular = cookTorranceSpecular(normalize(u_lightPosition), -normalize(v_position), v_normal, 0.027, 0.04);\n"
			"    vec3 diff = vec3(max(dot(v_normal,normalize(u_lightPosition)),0.0));\n"
			"    gl_FragColor = vec4(mix(u_ambient.xyz,vec3(diff)* u_diffuse.xyz*vec3(u_selectColor),0.95) + vec3(specular), u_diffuse.a);\n"
			"}"
			"else"
			"{"
			"    float specular = cookTorranceSpecular(normalize(u_lightPosition), -normalize(v_position),- v_normal, 0.027, 0.04);\n"
			"    vec3 diff = vec3(max(abs(dot(-v_normal,normalize(u_lightPosition))),0.0));\n"
			"    gl_FragColor = vec4(mix(u_ambient.xyz,vec3(diff)* u_diffuse.xyz*vec3(u_selectColor),0.95) + vec3(specular), u_diffuse.a);\n"
			"}"
			"}\n"
			"\n";
	}


	const char * ShaderSrcCode::EdgeDetectionVert()
	{
		return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec2 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"varying vec2 v_texCoords;\n"
			"void main(){\n"
			"gl_Position = u_projectionMat *u_viewMat*u_modelMat*vec4(a_position,1.0);\n"
			"v_texCoords = a_texCoords;\n"
			"}\n";
	}
	const char * ShaderSrcCode::EdgeDetectionFrag()
	{
		return
			"precision highp float;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform float u_xPixelOffset;\n"
			"uniform float u_yPixelOffset;\n"
			"varying vec2 v_texCoords;\n"
			"void main( void )\n"
			"{\n"
			"float _Size = 1024.0;\n"
			"   vec3 lum = vec3(0.2125,0.7154,0.0721);\n"
			"     float mc00 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0*u_xPixelOffset,1.0*u_yPixelOffset)).rgb, lum);\n"
			"     float mc10 = dot(texture2D (u_sampler0, v_texCoords-vec2(0.0,1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc20 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc01 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0,0.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc11mc = dot(texture2D (u_sampler0, v_texCoords).rgb, lum);\n"
			"     float mc21 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,0.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc02 = dot(texture2D (u_sampler0, v_texCoords-vec2(1.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc12 = dot(texture2D (u_sampler0, v_texCoords-vec2(0.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"     float mc22 = dot(texture2D (u_sampler0, v_texCoords-vec2(-1.0,-1.0)*vec2(u_xPixelOffset,u_yPixelOffset)).rgb, lum);\n"
			"\n"
			"     float GX = -1.0 * mc00 + mc20 + -2.0 * mc01 + 2.0 * mc21 - mc02 + mc22;\n"
			"     float GY = mc00 + 2.0 * mc10 + mc20 - mc02 - 2.0 * mc12 - mc22;\n"
			"     vec4 c;\n"
			"     float gratValue =length(vec2(GX,GY));\n "
			"     c = vec4(gratValue,gratValue,gratValue,1.0);\n"
			"\n"
			"      float factor = 1.0-c.x;\n"
			"      if(factor>0.92)\n"
			"      {\n"
			"      factor = 1.0;\n"
			"      }\n"
			"      else\n"
			"      {\n"
			"      factor = 0.0;\n"
			"      }\n"
			"   if(texture2D (u_sampler0, v_texCoords).a<0.33)"
			"{gl_FragColor = vec4(factor,0.0,0.0,1.0);}\n"
			"else"
			"{ gl_FragColor = vec4(factor,factor,factor,1.0);\n}"
			"}\n"
			"\n"
			;
	}

	const char * ShaderSrcCode::QuadVert()
	{
		return
			"precision highp float;\n"
			"attribute  vec3 a_position;\n"
			"attribute  vec2 a_texCoords;\n"
			"varying  vec2 v_texCoords;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = vec4(a_position,1.0);\n"
			"    v_texCoords = a_texCoords;\n"
			"}\n"
			"\n";
	}
	const char * ShaderSrcCode::QuadFrag()
	{
		return
			"precision highp float;\n"
			"uniform sampler2D u_sampler0;\n"
			"varying vec2 v_texCoords;\n"
			"void main() { \n"
			"gl_FragColor =texture2D(u_sampler0,v_texCoords);\n"
			"}\n";
	}
const char * ShaderSrcCode::MultilightPerFragVert()
{
	return "precision highp float;\n"
			"attribute vec3 a_position;\n"
			"attribute vec3 a_normal;\n"
			"attribute vec3 a_texCoords;\n"
			"uniform mat4 u_modelMat;\n"
			"uniform mat4 u_viewMat;\n"
			"uniform mat4 u_projectionMat;\n"
			"uniform mat4 u_normalMat;\n"
			"uniform mat4 u_textureMat;\n"
			"uniform vec3 u_lightPosition;\n"
			"uniform vec3 u_eyePosition;\n"
			"uniform vec4 u_ambient;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_specular;\n"
			"vec3 vviewDirection;\n"
			"vec3 vlightDirection;\n"
			"vec3 vnormal;\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec4 v_diffuseColor;\n"
			"varying vec4 v_specularColor;\n"
			"varying vec4 v_diffuseColorN;\n"
			"varying vec4 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"const vec4 ambientColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"const vec4 diffuseColor = vec4(1.0, 1.0, 1.0,1.0);\n"
			"uniform float u_shininess;\n"
			"const vec4 specularColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"void main() {\n"
			"gl_Position = u_projectionMat * u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 fvObjectPosition = u_viewMat*u_modelMat* vec4(a_position,1.0);\n"
			"vec4 tempCoords = u_textureMat*vec4(a_texCoords.xyz,1.0);\n"
			"v_position = fvObjectPosition.xyz/fvObjectPosition.w;\n"
			"v_texCoords = tempCoords;\n"
			"vviewDirection  = normalize( -fvObjectPosition.xyz);\n"
			"vlightDirection = normalize(u_lightPosition-fvObjectPosition.xyz);\n"
			"vnormal         = normalize(vec3((u_normalMat * vec4(a_normal,0.0))));\n"
			"v_normal = vnormal;\n"
			"float fNDotL =0.0;\n"
			"vec3 halfvector;\n"
			"float fNDotH;\n"
			"fNDotL           = clamp(abs(dot( vnormal, vlightDirection )),0.3,1.0);\n"
			"halfvector        =normalize(vlightDirection+ vviewDirection );\n"
			"fNDotH            = dot(vnormal,halfvector);\n"
			"vec4  fvTotalAmbient   = u_ambient * ambientColor;\n"
			"vec4  fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"vec4  fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColor=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColor = min(fvTotalSpecular,vec4(1.0));\n"
			"\n"
			"fNDotL           = clamp(abs(dot( -vnormal, vlightDirection )),0.3,1.0);\n"
			"fNDotH            = dot(-vnormal,halfvector);\n"
			"fvTotalDiffuse   = switchColor*u_diffuse * fNDotL * diffuseColor;\n"
			"fvTotalSpecular  = u_specular * specularColor *( pow( max(fNDotH,0.0), u_shininess ) );\n"
			"v_diffuseColorN=min(fvTotalAmbient + fvTotalDiffuse,vec4(1.0));\n"
			"v_specularColorN = min(fvTotalSpecular,vec4(1.0));\n"
			""
			"}\n"
			"\n"

	;
}
const char * ShaderSrcCode::MultilightPerFragFrag()
{
	return "precision highp float;\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"uniform bool u_useTex;\n"
			"uniform sampler2D u_sampler0;\n"
			"uniform vec4 u_diffuse;\n"
			"uniform vec4 u_selectColor;\n"
			"varying vec3 v_position;\n"
			"varying vec4 v_texCoords;\n"
			"varying vec4 v_diffuseColor;\n"
			"varying vec4 v_specularColor;\n"
			"varying vec4 v_diffuseColorN;\n"
			"varying vec4 v_specularColorN;\n"
			"varying vec3 v_normal;\n"
			"vec4 switchColor = vec4(1.0,1.0,1.0,1.0);\n"
			"vec4 environment = vec4(1.0);\n"
			"void main(void)\n"
			"{\n"
			"    if(u_enableClip){\n"
			"        float dPara = u_clipPlane.w;\n"
			"        if( (dot(vec3(v_position.xyz),vec3(u_clipPlane.xyz))+dPara)<0.0001){\n"
			"                    discard;\n"
			"            }\n"
			"    }\n"
			"    if(u_useTex){\n"
			"          switchColor = texture2D( u_sampler0, v_texCoords.xy );\n"
			"                }\n"
			"	vec4 texColor = switchColor *environment;\n"
			"    if(gl_FrontFacing){\n"
			"    	  gl_FragColor = vec4(vec3(texColor*v_diffuseColor)*vec3(u_selectColor)+vec3(v_specularColor),u_diffuse.a+1.0);\n"
			"    }else{\n"
			"         gl_FragColor = vec4(vec3(texColor*v_diffuseColorN)*vec3(u_selectColor)+vec3(v_specularColorN),u_diffuse.a+1.0);\n"
			"    }\n"
			"}\n"
			"\n";
}

#endif // WIN32


}

/* namespace M3D */
