#include "m3d/renderer/gl20/ShaderChunk.h"
namespace M3D
{

	bool ShaderChunk::m_needInit = true;

	map<string, string> ShaderChunk::m_shaderChunks;
	ShaderChunk::ShaderChunk()
	{
		Init();
	}


	ShaderChunk::~ShaderChunk()
	{
	}

	void ShaderChunk::Init()
	{

		m_shaderChunks["begin_vertex"] = "vec3 transformed = vec3( a_position );\n";
		m_shaderChunks["beginnormal_vertex"] = "vec3 objectNormal = vec3( a_normal );\n";
		m_shaderChunks["bsdfs"] = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n"
			"	if( decayExponent > 0.0 ) {\n"
			"\n"
			"#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n"
			"\n"
			"		// based upon Frostbite 3 Moving to Physically-based Rendering\n"
			"		// page 32, equation 26: E[window1]\n"
			"		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n"
			"		// this is intended to be used on spot and point lights who are represented as luminous intensity\n"
			"		// but who must be converted to luminous irradiance for surface lighting calculation\n"
			"		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n"
			"		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n"
			"		return distanceFalloff * maxDistanceCutoffFactor;\n"
			"\n"
			"#else\n"
			"\n"
			"		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n"
			"\n"
			"#endif\n"
			"\n"
			"	}\n"
			"\n"
			"	return 1.0;\n"
			"\n"
			"}\n"
			"\n"
			"vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n"
			"\n"
			"	return RECIPROCAL_PI * diffuseColor;\n"
			"\n"
			"} // validated\n"
			"\n"
			"vec3 F_Schlick( const in vec3 specularColor, const in float VdotH ) {\n"
			"\n"
			"	// Original approximation by Christophe Schlick '94\n"
			"	// float fresnel = pow( 1.0 - dotLH, 5.0 );\n"
			"\n"
			"	// Optimized variant (presented by Epic at SIGGRAPH '13)\n"
			"	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n"
			//"	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n"
			"\n"
			//"	return ( 1.0 - specularColor ) * fresnel + specularColor;\n"
			//按照babylon改进
			"  return specularColor + (1.0 - specularColor) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);"
			"\n"
			"} // validated\n"
			"\n"
			"vec3 fresnelSchlickRoughness(float dotNV, vec3 F0, float roughness)\n"
			"{\n"
			"    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - dotNV, 5.0);\n"
			"}\n"
			"\n"
			"// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n"
			"// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n"
			"// alpha is 'roughness squared' in Disney’s reparameterization\n"
			"float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n"
			"\n"
			"	// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n"
			"	// also see #12151\n"
			"\n"
			"	float a2 = pow2( alpha );\n"
			"\n"
			"	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n"
			"	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n"
			"\n"
			"	return 1.0 / ( gl * gv );\n"
			"\n"
			"} // validated\n"
			"\n"
			"// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n"
			"// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n"
			"float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n"
			"\n"
			"	float a2 = pow2( alpha );\n"
			"\n"
			"	// dotNL and dotNV are explicitly swapped. This is not a mistake.\n"
			"	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n"
			"	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n"
			"\n"
			"	return 0.5 / max( gv + gl, EPSILON );\n"
			"\n"
			"}\n"
			"\n"
			"// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n"
			"// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n"
			"// alpha is 'roughness squared' in Disney’s reparameterization\n"
			"float D_GGX( const in float alpha, const in float dotNH ) {\n"
			"\n"
			"	float a2 = pow2( alpha );\n"
			"\n"
			"	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n"
			"\n"
			"	return RECIPROCAL_PI * a2 / pow2( denom );\n"
			"\n"
			"}\n"
			"\n"
			"// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\n"
			"vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ,out vec3 ks) {\n"
			"\n"
			"	float alpha = pow2( roughness ); // UE4's roughness\n"
			"\n"
			"	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n"
			"\n"
			"	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n"
			"	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n"
			"	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n"
			"\n"
			"	vec3 F = F_Schlick( specularColor, dotVH );\n"
			"ks = F;\n"
			"\n"
			"	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n"
			"\n"
			"	float D = D_GGX( alpha, dotNH );\n"
			"\n"
			"	return F * ( G * D );\n"
			"\n"
			"} // validated\n"
			"\n"
			"\n"
			"// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\n"
			"vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n"
			"\n"
			"	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"\n"
			"	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n"
			"\n"
			"	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n"
			"\n"
			"	vec4 r = roughness * c0 + c1;\n"
			"\n"
			"	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n"
			"\n"
			"	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n"
			"\n"
			"	return specularColor * AB.x + AB.y;\n"
			"\n"
			"} // validated\n"
			"\n"
			"\n"
			"float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n"
			"\n"
			"	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n"
			"	return 0.25;\n"
			"\n"
			"}\n"
			"\n"
			"float D_BlinnPhong( const in float shininess, const in float dotNH ) {\n"
			"\n"
			"	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n"
			"\n"
			"}\n"
			"\n"
			"vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n"
			"\n"
			"	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n"
			"\n"
			"	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n"
			"	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n"
			"	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n"
			"\n"
			"	vec3 F = F_Schlick( specularColor, dotLH );\n"
			"\n"
			"	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n"
			"\n"
			"	float D = D_BlinnPhong( shininess, dotNH );\n"
			"\n"
			"	return F * ( G * D );\n"
			"\n"
			"} // validated\n"
			"\n"
			"// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\n"
			"float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n"
			"	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n"		
			"}\n"
			"\n"
			"float BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n"
			"	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n"
			"}\n"
			//"vec4 SRGBtoLINEAR(vec4 srgbIn)\n"
			//"{\n"
			//"\n"
			//"#ifdef PHYSICAL\n"
			//"    vec3 linOut = pow(srgbIn.xyz, vec3(gamma));\n"
			//"#else \n"
			//"    vec3 linOut = srgbIn.rgb;\n"
			//"#endif //PHYSICAL\n"
			//"    return vec4(linOut.rgb, srgbIn.w);\n"
			//"}\n"
			"#if defined(PHYSICAL) \n"	
			"vec3 BRDF_Specular_GGX_Environment_texture( const in GeometricContext geometry,const in vec3 specularColor, const in float roughness ) {\n"
			"\n"
			"	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			" vec3 brdf = (texture2D(lut, vec2(dotNV, 1.0-roughness))).rgb;\n"

			"\n"
			"	return specularColor * brdf.x + brdf.y;\n"
			"\n"			
			"} // validated\n"
				"vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness)\n"
				"{\n"
				"	vec3 dominant;\n"
				"   bool uSpecularPeak = true;\n"
				"	if (uSpecularPeak == true) {\n"
				"		float smoothness = 1.0 - realRoughness;\n"
				"		float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n"
				// The result is not normalized as we fetch in a cubemap
				"		dominant = mix(N, R, lerpFactor);\n"
				"	}\n"
				"	else {\n"
				"		dominant = R;\n"
				"	}\n"
				"	return dominant;\n"
				"}\n"
			
				"float occlusionHorizon(const in vec3 R, const in vec3 normal)\n"
				"{\n"
				"bool occlusion = true;\n"
				"if (occlusion == false)\n"
				"	return 1.0;\n"

				// http://marmosetco.tumblr.com/post/81245981087
				// marmoset uses 1.3, we force it to 1.0
				"float factor = clamp(1.0 + dot(R, normal), 0.0, 1.0);\n"
				"return factor * factor;\n"
				"}\n"
				"#endif\n"
;

		m_shaderChunks["clip_fragment"] = "#if defined(USE_CLIP)\n"
			"    if(u_enableClip)\n"
			"    {\n"
			"        float dPara = u_clipPlane.w;\n"
			"        float testvalue = (dot(-vec3(vViewPosition.xyz),vec3(u_clipPlane.xyz))+dPara);\n"
			"        if( testvalue<0.0)\n"
			"        {\n"
			"            discard;\n"
			"        }\n"
			"    }\n"
			"#endif\n";
		m_shaderChunks["clip_pars_fragment"] = "#if defined(USE_CLIP)\n"
			"uniform vec4 u_clipPlane;\n"
			"uniform bool u_enableClip;\n"
			"//varying vec3 vViewPosition;\n"
			"#endif \n";
		m_shaderChunks["clip_pars_vertex"] = "#if defined(USE_CLIP) \n"
			"//varying vec3 vViewPosition;\n"
			"#endif \n";
		m_shaderChunks["common"] = "#define PI 3.14159265359\n"
			"#define PI2 6.28318530718\n"
			"#define PI_HALF 1.5707963267949\n"
			"#define RECIPROCAL_PI 0.31830988618\n"
			"#define RECIPROCAL_PI2 0.15915494\n"
			"#define LOG2 1.442695\n"
			"#define EPSILON 1e-6\n"
			"#define saturate(a) clamp( a, 0.001, 1.0 )\n"
			"#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n"
			"float pow2( const in float x ) { return x*x; }\n"
			"float pow3( const in float x ) { return x*x*x; }\n"
			"float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\n"
			"float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n"
			"// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n"
			"// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\n"

			"struct IncidentLight {\n"
			"       vec3 color;\n"
			"       vec3 direction;\n"
			"       bool visible;\n"
			"};\n"
			"struct ReflectedLight {\n"
			"       vec3 directDiffuse;\n"
			"       vec3 directSpecular;\n"
			"       vec3 indirectDiffuse;\n"
			"       vec3 indirectSpecular;\n"
			"};\n"
			"struct GeometricContext {\n"
			"       vec3 position;\n"
			"       vec3 normal;\n"
			"       vec3 viewDir;\n"
			"};\n"
			"\n"
			"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n"
			"\n"
			"       return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n"
			"\n"
			"}\n"
			"\n"
			"// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n"
			"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n"
			"\n"
			"       return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n"
			"\n"
			"}\n"
			"\n"
			"\n"
			"// https://en.wikipedia.org/wiki/Relative_luminance\n"
			"float linearToRelativeLuminance( const in vec3 color ) {\n"
			"\n"
			"       vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n"
			"\n"
			"       return dot( weights, color.rgb );\n"
			"\n"
			"}\n";
		m_shaderChunks["defaultnormal_vertex"] = "\n"
			"vec3 transformedNormal = mat3(normalMatrix) * objectNormal;\n"
			"\n"
			"#ifdef FLIP_SIDED\n"
			"\n"
			"       transformedNormal = - transformedNormal;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["lights_pars"] = " uniform vec3 ambientLightColor;\n"
			"\n"
			"vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n"
			"\n"
			"       vec3 irradiance = ambientLightColor;\n"
			"\n"
			"       #ifndef PHYSICALLY_CORRECT_LIGHTS\n"
			"\n"
			"               irradiance *= PI;\n"
			"\n"
			"       #endif\n"
			"\n"
			"       return irradiance;\n"
			"\n"
			"}\n"
			"\n"
			"#if NUM_DIR_LIGHTS > 0\n"
			"\n"
			"       struct DirectionalLight {\n"
			"               vec3 direction;\n"
			"               vec3 color;\n"
			"\n"
			"               int shadow;\n"
			"               float shadowBias;\n"
			"               float shadowRadius;\n"
			"               vec2 shadowMapSize;\n"
			"       };\n"
			"\n"
			"       uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"       uniform bool directionMark[ NUM_DIR_LIGHTS ];\n"
			"#endif\n"
			"\n"
			"       void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n"
			"\n"
			"               directLight.color = directionalLight.color;\n"
			"               directLight.direction =normalize( vec3(/*viewMatrix**/vec4(directionalLight.direction,0.0)));\n"
			"               directLight.visible = true;\n"
			"\n"
			"       }\n"
			"\n"
			"#endif\n"
			"\n"
			"\n"
			"#if NUM_POINT_LIGHTS > 0\n"
			"\n"
			"       struct PointLight {\n"
			"               vec3 position;\n"
			"               vec3 color;\n"
			"               float distance;\n"
			"               float decay;\n"
			"\n"
			"               int shadow;\n"
			"               float shadowBias;\n"
			"               float shadowRadius;\n"
			"               vec2 shadowMapSize;\n"
			"               float shadowCameraNear;\n"
			"               float shadowCameraFar;\n"
			"       };\n"
			"\n"
			"       uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"       uniform bool pointMark[ NUM_POINT_LIGHTS ];\n"
			"#endif\n"
			"\n"
			"       // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n"
			"       void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n"
			"\n"
			"               vec3 lVector = vec3(/*viewMatrix**/vec4(pointLight.position,1.0)) - geometry.position;\n"
			"               directLight.direction = normalize( lVector );\n"
			"\n"
			"               float lightDistance = length( lVector );\n"
			"\n"
			"               directLight.color = pointLight.color;\n"
			"               directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n"
			"               directLight.visible = ( directLight.color != vec3( 0.0 ) );\n"
			"\n"
			"       }\n"
			"\n"
			"#endif\n"
			"\n"
			"\n"
			"#if NUM_SPOT_LIGHTS > 0\n"
			"\n"
			"       struct SpotLight {\n"
			"               vec3 position;\n"
			"               vec3 direction;\n"
			"               vec3 color;\n"
			"               float distance;\n"
			"               float decay;\n"
			"               float coneCos;\n"
			"               float penumbraCos;\n"
			"\n"
			"               int shadow;\n"
			"               float shadowBias;\n"
			"               float shadowRadius;\n"
			"               vec2 shadowMapSize;\n"
			"       };\n"
			"\n"
			"       uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"       uniform bool spotMark[ NUM_SPOT_LIGHTS ];\n"
			"#endif\n"
			"\n"
			"       // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n"
			"       void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n"
			"\n"
				"               vec3 lVector = vec3(/*viewMatrix**/vec4(spotLight.position,1.0)) - geometry.position;\n"
			"               directLight.direction = normalize( lVector );\n"
			"\n"
			"               float lightDistance = length( lVector );\n"
			"               float angleCos = dot( directLight.direction,normalize( vec3(/*viewMatrix**/vec4( spotLight.direction,0.0))) );\n"
			"\n"
			"               if ( angleCos > spotLight.coneCos ) {\n"
			"\n"
			"                       float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n"
			"\n"
			"                       directLight.color = spotLight.color;\n"
			"                       directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n"
			"                       directLight.visible = true;\n"
			"\n"
			"               } else {\n"
			"\n"
			"                       directLight.color = vec3( 0.0 );\n"
			"                       directLight.visible = false;\n"
			"\n"
			"               }\n"
			"       }\n"
			"\n"
			"#endif\n"
			"\n"
			"\n"
			"#if NUM_HEMI_LIGHTS > 0\n"

			"		struct HemisphereLight {\n"
			"				vec3 direction;\n"
			"				vec3 skyColor;\n"
			"				vec3 groundColor;\n"
			"			};\n"
			""
			"			uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\n"
			""
			"			vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in GeometricContext geometry) {\n"
			""
			"				float dotNL = dot(geometry.normal, normalize(vec3(/*viewMatrix**/vec4(hemiLight.direction,0.0))));\n"
			"				float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n"
			""
			"				vec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);\n"

			"#ifndef PHYSICALLY_CORRECT_LIGHTS\n"

			"				irradiance *= PI;\n"

			"#endif\n"

			"				return irradiance;\n"

			"			}\n"

			"#endif\n"
			"\n"
			"#if defined( USE_ENV_TEXTURE ) && defined( PHYSICAL )\n"
			"\n"
			"       vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n"
			"\n"
			"               vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n"
			"\n"
			"               #ifdef ENVTEXTURE_TYPE_CUBE\n"
			"\n"
			"                       vec3 queryVec = vec3(  worldNormal.x, worldNormal.yz );\n"
			"\n"
			"                       // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n"
			"                       // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n"
			"\n"
			//"                       #ifdef TEXTURE_LOD_EXT\n"
			"\n"
			//"                               vec4 envMapColor = textureCubeLod( envTexture, queryVec, float( maxMIPLevel ) );\n"
			"\n"
			//"                       #else\n"
			"\n"
			"                               // force the bias high to get the last LOD level as it is the most blurred.\n"
			"                               vec4 envMapColor = textureCube( envDiffuseTexture, queryVec );\n"
			"\n"
			//"                       #endif\n"
			//"                       vec4 envMapColor = textureCubeLod( envTexture, queryVec,float( maxMIPLevel ));\n"
			"\n"
			"                       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n"
			"\n"
			"               #else\n"
			"\n"
			"                       vec4 envMapColor = vec4( 0.0 );\n"
			"\n"
			"               #endif\n"
			"\n"
			"               return PI * envMapColor.rgb * envMapIntensity;\n"
			"\n"
			"       }\n"
			"\n"
			"       // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n"
			"       float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n"
			"\n"
			"               //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n"
			"               //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n"
			"\n"
			"               float maxMIPLevelScalar = float( maxMIPLevel );\n"
			"               float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n"
			"\n"
			"               // clamp to allowable LOD ranges.\n"
			"               return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n"
			
			"\n"
			"       }\n"
			"\n"
			"		float linRoughnessToMipmap(float roughnessLinear,const in int maxMIPLevel)\n"
			"		{\n"
			"           float maxMIPLevelScalar = float( maxMIPLevel );\n"
			"			return sqrt(roughnessLinear)*(maxMIPLevelScalar - 1.0);\n"
			"		}\n"
			"       vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n"
			"\n"
			"               #ifdef ENVTEXTURE_MODE_REFLECTION\n"
			"\n"
			"                       vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n"
			"\n"
			"               #else\n"
			"\n"
			"                       vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n"
			"\n"
			"               #endif\n"
			//"				 vec3 dominantR = getSpecularDominantDir( geometry.normal, reflectVec, blinnShininessExponent*blinnShininessExponent );\n"//specular peak
			//"				reflectVec = (dominantR);\n"
			"\n"
			"               reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n"
			""
			"\n"
//			"               float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n"
			"               float specularMIPLevel = linRoughnessToMipmap( blinnShininessExponent, maxMIPLevel );\n"
				"#ifdef USE_LOCAL_CUBEMAP\n"
				"reflectVec = GetParallaxCorrectedReflect( normalize(reflectVec), boxMax, boxMin, cubeMapWorldPosition, vWorldPosition);\n"
				//"reflectVec = fixSeams(reflectVec, specularMIPLevel);\n"
				//"reflectVec.x *= -1.0;\n"
				"#endif\n"
			"\n"
			"               #ifdef ENVTEXTURE_TYPE_CUBE\n"
			"\n"
			"                       vec3 queryReflectVec = vec3(  reflectVec.x, reflectVec.yz );\n"
			"\n"
			"                       #ifdef TEXTURE_LOD_EXT\n"
			"\n"
			"                               vec4 envMapColor = textureCubeLod( envTexture, queryReflectVec, specularMIPLevel );\n"
			"\n"
			"                       #else\n"
			"\n"
			"                               vec4 envMapColor = textureCube( envTexture, queryReflectVec, specularMIPLevel );\n"
			"\n"
			"                       #endif\n"
			"\n"
			"                       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n"
			"\n"		
			"\n"
			"               #elif defined( ENVMAP_TYPE_EQUIREC )\n"
			"\n"
			"                       vec2 sampleUV;\n"
			"                       sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n"
			"                       sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n"
			"\n"
			"                       #ifdef TEXTURE_LOD_EXT\n"
			"\n"
			"                               vec4 envMapColor = texture2DLodEXT( envTexture, sampleUV, specularMIPLevel );\n"
			"\n"
			"                       #else\n"
			"\n"
			"                               vec4 envMapColor = texture2D( envTexture, sampleUV, specularMIPLevel );\n"
			"\n"
			"                       #endif\n"
			"\n"
			"                       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n"
			"\n"
			"               #elif defined( ENVMAP_TYPE_SPHERE )\n"
			"\n"
			"                       vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n"
			"\n"
			"                       #ifdef TEXTURE_LOD_EXT\n"
			"\n"
			"                               vec4 envMapColor = texture2DLodEXT( envTexture, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n"
			"\n"
			"                       #else\n"
			"\n"
			"                               vec4 envMapColor = texture2D( envTexture, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n"
			"\n"
			"                       #endif\n"
			"\n"
			"                       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n"
			"\n"
			"               #endif\n"
			"\n"
		//	"				envMapColor.rgb*=	occlusionHorizon( dominantR, vNormal );\n"
			"               return envMapColor.rgb * envMapIntensity;\n"
			"\n"
			"       }\n"
			"\n"
			"#endif\n";
		m_shaderChunks["lights_phong_fragment"] = "BlinnPhongMaterial material;\n"
			"material.diffuseColor = diffuseColor.rgb;\n"
			"material.specularColor = specular.rgb;\n"
			"material.specularShininess = shininess;\n"
			"material.specularStrength = specularStrength;\n";
		m_shaderChunks["lights_phong_pars_fragment"] = "varying vec3 vViewPosition;\n"
			"\n"
			"#ifndef FLAT_SHADED\n"
			"\n"
			"       varying vec3 vNormal;\n"
			"\n"
			"#endif\n"
			"\n"
			"\n"
			"struct BlinnPhongMaterial {\n"
			"\n"
			"       vec3    diffuseColor;\n"
			"       vec3    specularColor;\n"
			"       float   specularShininess;\n"
			"       float   specularStrength;\n"
			"\n"
			"};\n"
			"\n"
			"void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n"
			"\n"
			"\n"
			"\n"
			"               float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n"
			"               vec3 irradiance = dotNL * directLight.color;\n"
			"\n"
			"\n"
			"\n"
			"        #ifndef PHYSICALLY_CORRECT_LIGHTS\n"
			"\n"
			"             irradiance *= PI; // punctual light\n"
			"\n"
			"        #endif\n"
			"\n"
			"       reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n"
			"\n"
			"       reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n"
			"\n"
			"}\n"
			"\n"
			"void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n"
			"\n"
			"       reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n"
			"\n"
			"}\n"
			"\n"
			" #define RE_Direct                           RE_Direct_BlinnPhong\n"
			" #define RE_IndirectDiffuse          RE_IndirectDiffuse_BlinnPhong\n"
			"\n"
			"#define Material_LightProbeLOD( material )     (0)\n";
		m_shaderChunks["lights_template"] = "/**\n"
			" * This is a template that can be used to light a material, it uses pluggable\n"
			" * RenderEquations (RE)for specific lighting scenarios.\n"
			" *\n"
			" * Instructions for use:\n"
			" * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n"
			" * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n"
			" * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n"
			" *\n"
			" * TODO:\n"
			" * - Add area light support.\n"
			" * - Add sphere light support.\n"
			" * - Add diffuse light probe (irradiance cubemap) support.\n"
			" */\n"
			"\n"
			"GeometricContext geometry;\n"
			"\n"
			"geometry.position = - vViewPosition;\n"
			"geometry.normal = normal;\n"
			"geometry.viewDir = normalize( vViewPosition );\n"
			"\n"
			"IncidentLight directLight;\n"
			"\n"
			"vec4 coord = vec4(1.0,0.0,0.0,1.0);\n"
			"#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n"
			"\n"
			"       PointLight pointLight;\n"
			"\n"
			"       for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"               if(pointMark[ i ] == true){\n"
			"#endif\n"
			"			pointLights[ i ].position;"
			"			pointLights[ i ].color;"
			"			pointLights[ i ].distance;"
			"			pointLights[ i ].decay;"
			"			pointLights[ i ].shadow;"
			"			pointLights[ i ].shadowBias;"
			"			pointLights[ i ].shadowRadius;"
			"			pointLights[ i ].shadowMapSize;"
			"			pointLights[ i ].shadowCameraNear;"
			"			pointLights[ i ].shadowCameraFar;\n"

			"               pointLight = pointLights[ i ];\n"
			"\n"

			"               getPointDirectLightIrradiance( pointLight, geometry, directLight );\n"
			"//coord = vPointShadowCoord[i];\n"
			"       #ifdef USE_SHADOWMAP\n"
			"               vec3 lVector = pointLight.position - geometry.position;\n"
			"               float bias = max(pointLight.shadowBias*10.0*(1.0-dot(normalize(lVector), geometry.normal)), pointLight.shadowBias);\n"
			"               directLight.color *= bool(pointLight.shadow)?getPointShadow(pointShadowMap[i],pointLight.shadowMapSize, bias, pointLight.shadowRadius, vPointShadowCoord[i],pointLight.shadowCameraNear, pointLight.shadowCameraFar):1.0 ;\n"
			"       #endif\n"
			"\n"
			"               RE_Direct( directLight, geometry, material, reflectedLight );\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"   }\n"
			"#endif\n"
			" }\n"
			"\n"
			"#endif\n"
			"\n"
			"#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n"
			"\n"
			"       SpotLight spotLight;\n"
			"\n"
			"       for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n"
			"\n"
			"			spotLights[ i ].position;"
			"			spotLights[ i ].direction;"
			"			spotLights[ i ].color;"
			"			spotLights[ i ].distance;"
			"			spotLights[ i ].decay;"
			"			spotLights[ i ].coneCos;"
			"			spotLights[ i ].penumbraCos;"
			"			spotLights[ i ].shadow;"
			"			spotLights[ i ].shadowBias;"
			"			spotLights[ i ].shadowRadius;"
			"			spotLights[ i ].shadowMapSize;\n"
			
			
			"               spotLight = spotLights[ i ];\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"               if(spotMark[ i ] == true){\n"
			"#endif\n"
			
			"               getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n"
			"       #ifdef USE_SHADOWMAP\n"
			"               vec3 lVector = spotLight.position - geometry.position;\n"
			"               float bias = max(spotLight.shadowBias*3.0*(1.0-dot(normalize(lVector), geometry.normal)), spotLight.shadowBias);\n"
			"               directLight.color *= bool(spotLight.shadow)?getShadow(spotShadowMap[i],spotLight.shadowMapSize, bias, spotLight.shadowRadius, vSpotShadowCoord[i]):1.0 ;\n"
			"       #endif\n"
			"\n"
			"               RE_Direct( directLight, geometry, material, reflectedLight );\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"   }\n"
			"#endif\n"
			"}\n"
			"\n"
			"#endif\n"
			"\n"
			"float ss = 1.0;\n"
				"vec3 testColor = vec3(0.0);\n"
			"#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n"
			"\n"
			"       DirectionalLight directionalLight;\n"
			"\n"
			"       for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n"
			"\n"
			"             directionalLights[ i ] . direction;"
				"             directionalLights[ i ] . color;"
				"             directionalLights[ i ] . shadow;"
				"             directionalLights[ i ] . shadowBias;"
				"             directionalLights[ i ] . shadowRadius;"
				"             directionalLights[ i ] . shadowMapSize;"
			"               directionalLight = directionalLights[ i ];\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"               if(directionMark[ i ] == true){\n"
			"#endif\n"
			"               getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n"
			"        #ifdef USE_SHADOWMAP\n"
			"               vec3 lVector = directionalLight.direction;\n"
			"               float bias = max(directionalLight.shadowBias*10.0*(1.0-dot(normalize(lVector), geometry.normal)), directionalLight.shadowBias);\n"
				"               directLight.color *=bool( directionalLight.shadow)?(getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,bias, directionalLight.shadowRadius,    vDirectionalShadowCoord[i])/*<1.0?0.50:1.0*/):1.0 ;\n"
				"//#if defined(USE_DIFFUSEMAP)\n"
				" //testColor = texture2D(directionalShadowMap[i],vUv);\n"
				"//#endif\n"
			"        #endif\n"
			"\n"
			"               RE_Direct( directLight, geometry, material, reflectedLight );\n"
			"#if defined(USE_LIGHT_MARK)\n"
			"   }\n"
			"#endif\n"
			"}\n"
			"\n"
			"#endif\n"
			"\n"
			"\n"
			"#if defined( RE_IndirectDiffuse )\n"
			"\n"
			"       vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n"
			"\n"
			"\n"
			"#if ( NUM_HEMI_LIGHTS > 0 )\n"

			"	for (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\n"
			"		hemisphereLights[i].direction;"
			"		hemisphereLights[i].skyColor;"
			"		hemisphereLights[i].groundColor;\n"
			"		irradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n"

			"	}\n"

			"#endif\n"
			"       #if defined( USE_ENV_TEXTURE ) && defined( PHYSICAL )\n"
			"\n"
			"               // TODO, replace 8 with the real maxMIPLevel\n"
			"              // irradiance = vec3(0.0);\n"
			"               irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 9 );\n"
			"\n"
			"       #endif\n"
			"\n"
			"       RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n"
			"\n"
			"#if defined( USE_MATCAPMAP ) &&  !defined( PHYSICAL )\n"
			"	irradiance = GetMatcapIndirectLight(geometry);\n"
			"  reflectedLight.indirectDiffuse += (irradiance) /** (material.diffuseColor)*/;\n"
				//"	vec3 lumcoeff = vec3( 0.2126, 0.7152, 0.0722 );\n"
				//"	float lum = dot( vec3(material.diffuseColor), lumcoeff );\n"
				//"	vec3 luminance = vec3( lum );\n"
				//" reflectedLight.indirectDiffuse += vec3( material.diffuseColor * mix( (irradiance), vec3( 1.0 ), luminance  ) );\n"
			"#endif\n"
			"#endif\n"
			"\n"
			"#if defined( USE_ENV_TEXTURE ) && defined( RE_IndirectSpecular )\n"
			"\n"
			"       // TODO, replace 8 with the real maxMIPLevel\n"
//old			"       vec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 9 );\n"
			"       vec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, ( material.specularRoughness ), 9 );\n"
			"   #ifndef STANDARD\n"
//old			"   vec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), 9 );\n"
			"   vec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, ( material.clearCoatRoughness ), 9 );\n"
			"   #else\n"
			"   vec3 clearCoatRadiance = vec3( 0.0 );\n"
			"   #endif\n"
			"   RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n"
			"\n"
			"#endif\n";
		m_shaderChunks["normalmap_pars_fragment"] =
			"#ifdef USE_NORMALMAP\n"

			"uniform sampler2D normalMap;\n"
			"uniform vec2 normalScale;\n"//TODO
			//"vec2 normalScale = vec2(5.0);\n"
			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm) {\n"

			// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

			"	vec3 q0 = vec3(dFdx(eye_pos.x), dFdx(eye_pos.y), dFdx(eye_pos.z));\n"
			"	vec3 q1 = vec3(dFdy(eye_pos.x), dFdy(eye_pos.y), dFdy(eye_pos.z));\n"
			"	vec2 st0 = dFdx(vUv.st);\n"
			"	vec2 st1 = dFdy(vUv.st);\n"

			"	vec3 S = normalize(q0 * st1.t - q1 * st0.t);\n"
			"	vec3 T = normalize(-q0 * st1.s + q1 * st0.s);\n"
			"	vec3 N = normalize(surf_norm);\n"

			"	vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n"
			"	mapN.xy = normalScale * mapN.xy;\n"
			"	mat3 tsn = mat3(S, T, N);\n"
			"	return normalize(tsn * mapN);\n"
			"}\n"
			"#endif\n"
			""
			;
		m_shaderChunks["normal_fragment"] = "#ifdef FLAT_SHADED\n"
			"\n"
			"       // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n"
			"\n"
			"       vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n"
			"       vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n"
			"       vec3 normal = normalize( cross( fdx, fdy ) );\n"
			"\n"
			"#else\n"
			"\n"
			"       vec3 normal = normalize( vNormal );\n"
			"\n"
			"       #ifdef DOUBLE_SIDED\n"
			"\n"
			"               normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n"
			"\n"
			"       #endif\n"
			"\n"
			"#endif\n"
			"\n"
			"#ifdef USE_NORMALMAP\n"
			"\n"
			"       normal = perturbNormal2Arb( -vViewPosition, normal );\n"
			"\n"
			"#elif defined( USE_BUMPMAP )\n"
			"\n"
			"       normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n"
			"\n"
			"#endif\n";
		m_shaderChunks["project_vertex"] = "vec4 mvPosition = viewMatrix*modelMatrix * vec4( transformed, 1.0 );\n"
			"\n"
			"gl_Position = projectionMatrix * mvPosition;\n";
		m_shaderChunks["specularmap_fragment"] = "float specularStrength;\n"
			"\n"
			"#ifdef USE_SPECULARMAP\n"
			"\n"
			"       vec4 texelSpecular = texture2D( specularMap, vUv );\n"
			"       specularStrength = texelSpecular.r;\n"
			"\n"
			"#else\n"
			"\n"
			"       specularStrength = 1.0;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["specularmap_pars_fragment"] =
			"#ifdef USE_SPECULARMAP\n"
			"\n"
			"       uniform sampler2D specularMap;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["uv_pars_fragment"] =
			"#if defined( USE_DIFFUSEMAP) || defined(USE_AOMAP) || defined(USE_EMISSIVEMAP)||defined(USE_NORMALMAP)||defined(USE_SPECULARMAP)||defined(USE_METALLIC_ROUGHNESS_TEXTURE)\n"
			"    varying vec2 vUv;   \n"
			"#endif\n";
		m_shaderChunks["uv_pars_vertex"] =
			"#if defined( USE_DIFFUSEMAP) || defined(USE_AOMAP) || defined(USE_EMISSIVEMAP)||defined(USE_NORMALMAP)||defined(USE_SPECULARMAP)||defined(USE_METALLIC_ROUGHNESS_TEXTURE)\n"
			"    varying vec2 vUv;\n"
			"    uniform mat3 uvTransform;\n"
			"#endif\n";
		m_shaderChunks["worldpos_vertex"] = "#if defined( USE_ENV_TEXTURE ) ||defined ( DISTANCE ) ||defined ( USE_SHADOWMAP )\n"
			"\n"
			"       vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n"
			"\n"
			"#endif\n";
		m_shaderChunks["uv_vertex"] = "#if defined( USE_DIFFUSEMAP ) || defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHA_TEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_METALLIC_ROUGHNESS_TEXTURE )\n"
			"\n"
			"       vUv = ( uvTransform* vec3( a_texCoords.xy,1.0) ).xy;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["map_pars_fragment"] = "#ifdef USE_DIFFUSEMAP\n"
			"\n"
			"       uniform sampler2D diffuseTexture;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["map_fragment"] = "#ifdef USE_DIFFUSEMAP\n"
			"\n"
			"       vec4 texelColor = texture2D( diffuseTexture, vUv );\n"
			"\n"
			"       texelColor = mapTexelToLinear( texelColor );\n"
			"       diffuseColor *= texelColor;\n"
			"\n"
			"#endif\n";
		m_shaderChunks["metallicRoughness_pars_fragment"] = 
			"#ifdef USE_METALLIC_ROUGHNESS_TEXTURE\n"
			"   uniform sampler2D metallicRoughnessTexture;\n"
			"#endif\n";
		m_shaderChunks["metallicRoughness_fragment"] = 
			"float roughnessFactor = roughness;\n"
			"float metalnessFactor = metalness;\n"
			"#ifdef USE_METALLIC_ROUGHNESS_TEXTURE\n"
			"vec4 mrSample = texture2D( metallicRoughnessTexture, vUv );\n"
			"roughnessFactor *= mrSample.g;\n"
			"metalnessFactor *= mrSample.b;\n"
			"#endif\n";
		m_shaderChunks["lights_physical_pars_fragment"] = "struct PhysicalMaterial {\n"
			"\n"
			"       vec3    diffuseColor;\n"
			"       float   specularRoughness;\n"
			"       float   metalness;\n"
			"       vec3    specularColor;\n"
			"	    #ifndef STANDARD\n"
			"       float clearCoat;\n"
			"       float clearCoatRoughness;\n"
			"       #endif\n"
			"};\n"
			"\n"
			"#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n"
			"#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n"
			"\n"
			"// Clear coat directional hemishperical reflectance (this approximation should be improved)\n"
			"float clearCoatDHRApprox( const in float roughness, const in float dotNL) {\n"
			"\n"
			//"    return DEFAULT_SPECULAR_COEFFICIENT + (max((1.0 - roughness), DEFAULT_SPECULAR_COEFFICIENT) - DEFAULT_SPECULAR_COEFFICIENT) * pow(1.0 - dotNL, 5.0);\n"			
			//"       return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n"
			"\n"
			"	float F0 = DEFAULT_SPECULAR_COEFFICIENT;"
			"	float Fc =pow( 1.0 - dotNL, 5.0 );"
			"	float F = Fc + (1.0 - Fc) * F0;"
			"   return F;\n"
			"}\n"
			"\n"
			"void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n"
			"\n"
			"       float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n"
			//"       float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"\n"
			"       vec3 irradiance = dotNL * directLight.color;\n"
			"\n"
			"       #ifndef PHYSICALLY_CORRECT_LIGHTS\n"
			"\n"
			"               irradiance *= PI; // punctual light\n"
			"\n"
			"       #endif\n"
			"       #ifndef STANDARD\n"
			"		vec3 halfDir = normalize( directLight.direction + geometry.viewDir );\n"		
			"		float dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n"
			"       float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotVH );\n"
			"       #else\n"
			"       float clearCoatDHR = 0.0;\n"
			"       #endif\n"
			"		vec3 ks = vec3(0.0);\n"
			"       reflectedLight.directSpecular +=  ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness,ks);\n"
			"\n"
			"       reflectedLight.directDiffuse +=  ( 1.0 - clearCoatDHR )*(1.0-ks) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n"
			"       #ifndef STANDARD\n"

			"       reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX(directLight, geometry, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearCoatRoughness,ks);\n"

			"       #endif\n"
			"\n"
			"}\n"
			"\n"
			"void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n"
			"\n"
			//辐照度要考虑能量守恒
			"       float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"       vec3 ks = fresnelSchlickRoughness(dotNV,material.specularColor,material.specularRoughness);\n"
			"       reflectedLight.indirectDiffuse += irradiance *(1.0-ks)* BRDF_Diffuse_Lambert( material.diffuseColor );\n"
			"\n"
			"}\n"
			"\n"
			"void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n"
			"       #ifndef STANDARD\n"
			"       float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"       float dotNL = dotNV;\n"		
			"       float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n"
			"       #else\n"
			//"       float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n"
			"               float clearCoatDHR = 0.0;\n"
			"       #endif\n"
			//辐照度要考虑能量守恒
			//"vec3 F = fresnelSchlickRoughness(dotNV,material.specularColor,material.specularRoughness );\n"
			"       reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR )* radiance * BRDF_Specular_GGX_Environment_texture( geometry, material.specularColor, material.specularRoughness );\n"

			"	    #ifndef STANDARD\n"
			"       reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment_texture(geometry, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearCoatRoughness);\n"
			"       #endif\n"

			"}\n"
			"\n"
			"#define RE_Direct                              RE_Direct_Physical\n"
			"#define RE_Direct_RectArea             RE_Direct_RectArea_Physical\n"
			"#define RE_IndirectDiffuse             RE_IndirectDiffuse_Physical\n"
			"#define RE_IndirectSpecular            RE_IndirectSpecular_Physical\n"
			"\n"
			"#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n"
			"#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n"
			"\n"
			"// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n"
			"float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n"
			"\n"
			"       return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n"
			"\n"
			"}\n";
		m_shaderChunks["lights_physical_fragment"] = "PhysicalMaterial material;\n"
			"material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n"
			"material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n"
			"#ifdef STANDARD\n"
			"material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n"
			"#else\n"
			"material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n"
			"material.clearCoat = saturate( clearCoat );\n"
			"material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n"
			"#endif\n"
			"material.metalness = metalness;\n"
			"\n";
		m_shaderChunks["envmap_pars_vertex"] = "#ifdef USE_ENV_TEXTURE\n"
			"\n"
			"       #if defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( PHONG )\n"
			"               varying vec3 vWorldPosition;\n"
			"\n"
			"       #else\n"
			"\n"
			"               varying vec3 vReflect;\n"
			"               uniform float refractionRatio;\n"
			"\n"
			"       #endif\n"
			"\n"
			"#endif\n";
		m_shaderChunks["envmap_vertex"] = "#ifdef USE_ENV_TEXTURE\n"
			"\n"
			"       #if defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( PHONG )\n"
			"\n"
			"               vWorldPosition = worldPosition.xyz;\n"
			"\n"
			"       #else\n"
			"\n"
			"               vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n"
			"\n"
			"               vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n"
			"\n"
			"               #ifdef ENVTEXTURE_MODE_REFLECTION\n"
			"\n"
			"                       vReflect = reflect( cameraToVertex, worldNormal );\n"
			"\n"
			"               #else\n"
			"\n"
			"                       vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n"
			"\n"
			"               #endif\n"
			"\n"
			"       #endif\n"
			"\n"
			"#endif\n";
		m_shaderChunks["envmap_pars_fragment"] = "#if defined( USE_ENV_TEXTURE ) || defined( PHYSICAL )\n"
			"       float reflectivity = 0.5;\n"
			"       uniform float envMapIntensity;\n"
			"#endif\n"
			"\n"
			"#ifdef USE_ENV_TEXTURE\n"
			"\n"
			"       #if ! defined( PHYSICAL ) && ( defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n"
			"               varying vec3 vWorldPosition;\n"
			"       #endif\n"
			"\n"
			"       #ifdef ENVTEXTURE_TYPE_CUBE\n"
			"               uniform samplerCube envTexture;\n"
			"               #if defined( PHYSICAL ) \n"
			"               uniform samplerCube envDiffuseTexture;\n"
			"               #endif\n"
			"       #else\n"
			"               uniform sampler2D envTexture;\n"
			"       #endif\n"
			"       uniform float flipEnvMap;\n"
			"\n"
			"       #if defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n"
			"               uniform float refractionRatio;\n"
			"       #else\n"
			"               varying vec3 vReflect;\n"
			"       #endif\n"
			"\n"
			"#endif\n";
		m_shaderChunks["envmap_fragment"] = "#ifdef USE_ENV_TEXTURE\n"
			"\n"
			"       #if defined( USE_BUMP_TEXTURE ) || defined( USE_NORMALMAP ) || defined( PHONG )\n"
			"\n"
			"               vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n"
			"\n"
			"               // Transforming Normal Vectors with the Inverse Transformation\n"
			"               vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n"
			"\n"
			"               #ifdef ENVTEXTURE_MODE_REFLECTION\n"
			"\n"
			"                       vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n"
			"\n"
			"               #else\n"
			"\n"
			"                       vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n"
			"\n"
			"               #endif\n"
			"\n"
			"       #else\n"
			"\n"
			"               vec3 reflectVec = vReflect;\n"
			"\n"
			"       #endif\n"
			"\n"
			"       #ifdef ENVTEXTURE_TYPE_CUBE\n"
			"\n"
			"               vec4 envColor = textureCube( envTexture, vec3(  reflectVec.x, reflectVec.yz ) );\n"
			"\n"
			"       #elif defined( ENVMAP_TYPE_EQUIREC )\n"
			"\n"
			"               vec2 sampleUV;\n"
			"\n"
			"               reflectVec = normalize( reflectVec );\n"
			"\n"
			"               sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n"
			"\n"
			"               sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n"
			"\n"
			"               vec4 envColor = texture2D( envTexture, sampleUV );\n"
			"\n"
			"       #elif defined( ENVMAP_TYPE_SPHERE )\n"
			"\n"
			"               reflectVec = normalize( reflectVec );\n"
			"\n"
			"               vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n"
			"\n"
			"               vec4 envColor = texture2D( envTexture, reflectView.xy * 0.5 + 0.5 );\n"
			"\n"
			"       #else\n"
			"\n"
			"               vec4 envColor = vec4( 0.0 );\n"
			"\n"
			"       #endif\n"
			"\n"
			"       envColor = envMapTexelToLinear( envColor );\n"
			"\n"
			"       #ifdef ENVMAP_BLENDING_MULTIPLY\n"
			"\n"
			"               outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n"
			"\n"
			"       #elif defined( ENVMAP_BLENDING_MIX )\n"
			"\n"
			"               outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n"
			"\n"
			"       #elif defined( ENVMAP_BLENDING_ADD )\n"
			"\n"
			"               outgoingLight += envColor.xyz * specularStrength * reflectivity;\n"
			"\n"
			"       #endif\n"
			"\n"
			"#endif\n";
		m_shaderChunks["packing"] = "vec3 packNormalToRGB( const in vec3 normal ) {\n"
			"       return normalize( normal ) * 0.5 + 0.5;\n"
			"}\n"
			"\n"
			"vec3 unpackRGBToNormal( const in vec3 rgb ) {\n"
			"       return 2.0 * rgb.xyz - 1.0;\n"
			"}\n"
			"\n"
			"const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\n"
			"const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n"
			"\n"
			"const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n"
			"const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n"
			"\n"
			"const float ShiftRight8 = 1. / 256.;\n"
			"\n"
			"vec4 packDepthToRGBA( const in float v ) {\n"
			"       vec4 r = vec4( fract( v * PackFactors ), v );\n"
			"       r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n"
			"       return r * PackUpscale;\n"
			"}\n"
			"\n"
			"float unpackRGBAToDepth( const in vec4 v ) {\n"
			"       return dot( v, UnpackFactors );\n"
			"}\n"
			"\n"
			"// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n"
			"\n"
			"float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n"
			"       return ( viewZ + near ) / ( near - far );\n"
			"}\n"
			"float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n"
			"       return linearClipZ * ( near - far ) - near;\n"
			"}\n"
			"\n"
			"float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n"
			"       return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n"
			"}\n"
			"float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n"
			"       return ( near * far ) / ( ( far - near ) * invClipZ - far );\n"
			"}\n";
		m_shaderChunks["shadowmap_vertex"] = "#ifdef USE_SHADOWMAP\n"
			"\n"
			"       #if NUM_DIR_LIGHTS > 0\n"
			"       for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n"
			"               vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n"
			"       }\n"
			"       #endif\n"
			"\n"
			"       #if NUM_SPOT_LIGHTS > 0\n"
			"       for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n"
			"               vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n"
			"       }\n"
			"       #endif\n"
			"\n"
			"       #if NUM_POINT_LIGHTS > 0\n"
			"       for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n"
			"               vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n"
			"       }\n"
			"       #endif\n"
			"#endif\n";
		m_shaderChunks["shadowmap_pars_vertex"] = "#ifdef USE_SHADOWMAP\n"
			"\n"
			"       #if NUM_DIR_LIGHTS > 0\n"
			"               uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n"
			"               varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"       #if NUM_SPOT_LIGHTS > 0\n"
			"               uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n"
			"               varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"       #if NUM_POINT_LIGHTS > 0\n"
			"               uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n"
			"               varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"#endif\n";
		m_shaderChunks["shadowmap_pars_fragment"] = "#ifdef USE_SHADOWMAP\n"
			"\n"
			"       #if NUM_DIR_LIGHTS > 0\n"
			"               uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n"
			"               varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"       #if NUM_SPOT_LIGHTS > 0\n"
			"               uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n"
			"               varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"       #if NUM_POINT_LIGHTS > 0\n"
			"               uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n"
			"               varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n"
			"       #endif\n"
			"\n"
			"       float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n"
			"               return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n"
			"       }\n"
			"\n"
			"       float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n"
			"               const vec2 offset = vec2( 0.0, 1.0 );\n"
			"\n"
			"               vec2 texelSize = vec2( 1.0 ) / size;\n"
			"               vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n"
			"\n"
			"               float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n"
			"               float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n"
			"               float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n"
			"               float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n"
			"\n"
			"               vec2 f = fract( uv * size + 0.5 );\n"
			"\n"
			"               float a = mix( lb, lt, f.y );\n"
			"               float b = mix( rb, rt, f.y );\n"
			"               float c = mix( a, b, f.x );\n"
			"\n"
			"               return c;\n"
			"       }\n"
			"\n"
			"       float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n"
			"\n"
			"               float shadow = 1.0;\n"
			"\n"
			"               shadowCoord.xyz /= shadowCoord.w;\n"
			"               shadowCoord.z -= shadowBias;\n"
			"\n"
			"               // if ( something && something ) breaks ATI OpenGL shader compiler\n"
			"               // if ( all( something, something ) ) using this instead\n"
			"\n"
			"               bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n"
			"               bool inFrustum = all( inFrustumVec );\n"
			"\n"
			"               bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n"
			"\n"
			"               bool frustumTest = all( frustumTestVec );\n"
			"\n"
			"               if ( frustumTest ) {\n"
			"\n"
			"               #if defined( SHADOWMAP_TYPE_PCF )\n"
			"\n"
			"                       vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n"
			"\n"
			"                       float dx0 = - texelSize.x * shadowRadius;\n"
			"                       float dy0 = - texelSize.y * shadowRadius;\n"
			"                       float dx1 = + texelSize.x * shadowRadius;\n"
			"                       float dy1 = + texelSize.y * shadowRadius;\n"
			"\n"
			"                       shadow = (\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n"
			"                               texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n"
			"                       ) * ( 1.0 / 9.0 );\n"
			"\n"
			"               #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n"
			"\n"
			"                       vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n"
			"\n"
			"                       float dx0 = - texelSize.x * shadowRadius;\n"
			"                       float dy0 = - texelSize.y * shadowRadius;\n"
			"                       float dx1 = + texelSize.x * shadowRadius;\n"
			"                       float dy1 = + texelSize.y * shadowRadius;\n"
			"\n"
			"                       shadow = (\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n"
			"                               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n"
			"                       ) * ( 1.0 / 9.0 );\n"
			"\n"
			"               #else // no percentage-closer filtering:\n"
			"\n"
			"                       shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n"
			"\n"
			"               #endif\n"
			"\n"
			"               }\n"
			"               if(shadowCoord.z>1.0)\n"
			"               {\n"
			"                   shadow = 1.0;\n"
			"               \n"
			"               }\n"
			"\n"
			"               return shadow;\n"
			"\n"
			"       }\n"
			"\n"
			"       // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n"
			"       // vector suitable for 2D texture mapping. This code uses the following layout for the\n"
			"       // 2D texture:\n"
			"       //\n"
			"       // xzXZ\n"
			"       //  y Y\n"
			"       //\n"
			"       // Y - Positive y direction\n"
			"       // y - Negative y direction\n"
			"       // X - Positive x direction\n"
			"       // x - Negative x direction\n"
			"       // Z - Positive z direction\n"
			"       // z - Negative z direction\n"
			"       //\n"
			"       // Source and test bed:\n"
			"       // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n"
			"\n"
			"       vec2 cubeToUV( vec3 v, float texelSizeY ) {\n"
			"\n"
			"               // Number of texels to avoid at the edge of each square\n"
			"\n"
			"               vec3 absV = abs( v );\n"
			"\n"
			"               // Intersect unit cube\n"
			"\n"
			"               float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n"
			"               absV *= scaleToCube;\n"
			"\n"
			"               // Apply scale to avoid seams\n"
			"\n"
			"               // two texels less per square (one texel will do for NEAREST)\n"
			"               v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n"
			"\n"
			"               // Unwrap\n"
			"\n"
			"               // space: -1 ... 1 range for each square\n"
			"               //\n"
			"               // #X##         dim    := ( 4 , 2 )\n"
			"               //  # #         center := ( 1 , 1 )\n"
			"\n"
			"               vec2 planar = v.xy;\n"
			"\n"
			"               float almostATexel = 1.5 * texelSizeY;\n"
			"               float almostOne = 1.0 - almostATexel;\n"
			"\n"
			"               if ( absV.z >= almostOne ) {\n"
			"\n"
			"                       if ( v.z > 0.0 )\n"
			"                               planar.x = 4.0 - v.x;\n"
			"\n"
			"               } else if ( absV.x >= almostOne ) {\n"
			"\n"
			"                       float signX = sign( v.x );\n"
			"                       planar.x = v.z * signX + 2.0 * signX;\n"
			"\n"
			"               } else if ( absV.y >= almostOne ) {\n"
			"\n"
			"                       float signY = sign( v.y );\n"
			"                       planar.x = v.x + 2.0 * signY + 2.0;\n"
			"                       planar.y = v.z * signY - 2.0;\n"
			"\n"
			"               }\n"
			"\n"
			"               // Transform to UV space\n"
			"\n"
			"               // scale := 0.5 / dim\n"
			"               // translate := ( center + 0.5 ) / dim\n"
			"               return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n"
			"\n"
			"       }\n"
			"\n"
			"       float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n"
			"\n"
			"               vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n"
			"\n"
			"               // for point lights, the uniform @vShadowCoord is re-purposed to hold\n"
			"               // the vector from the light to the world-space position of the fragment.\n"
			"               vec3 lightToPosition = shadowCoord.xyz;\n"
			"\n"
			"               // dp = normalized distance from light to fragment position\n"
			"               float  dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\n"
			"		        dp -= shadowBias;\n"
			"               // bd3D = base direction 3D\n"
			"               vec3 bd3D = normalize( lightToPosition );\n"

			"\n"
			"               #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n"
			"\n"
			"                       vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n"
			"\n"
			"                       return (\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n"
			"                               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n"
			"                       ) * ( 1.0 / 9.0 );\n"
			"\n"
			"               #else // no percentage-closer filtering\n"
			"\n"
			"                       return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n"
			"\n"
			"               #endif\n"
			"\n"
			"       }\n"
			"\n"
			"#endif\n";
		m_shaderChunks["z_depth_pars_vert"] = "#ifdef USE_DEPTH_TEXTURE_CULL\n"
			"uniform mat4 zMatrix;\n"
			"varying vec4 zCoords;\n"
			"#endif";
		m_shaderChunks["z_depth_pars_frag"] = "#ifdef USE_DEPTH_TEXTURE_CULL\n"
			"varying vec4 zCoords;\n"
			"uniform sampler2D zDepth;\n"
			"#endif\n"
			;
		m_shaderChunks["z_depth_vert"] = "#ifdef USE_DEPTH_TEXTURE_CULL\n"
			"zCoords = zMatrix * worldPosition;\n"
			"#endif\n";
		m_shaderChunks["z_depth_frag"] = "#ifdef USE_DEPTH_TEXTURE_CULL\n"
			"vec4 temZcoords = zCoords;\n"
			"temZcoords.xyz /= temZcoords.w;\n"
			"float zdepth =unpackRGBAToDepth(texture2D(zDepth, temZcoords.xy));\n"
			"if(gl_FragCoord.z>zdepth+0.000005)\n"
			"   discard;\n"
			"#endif\n";
		m_shaderChunks["tonemapping_pars_fragment"] = 
			"uniform float toneMappingExposure;\n"
			"#define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))\n"
			"vec3 Uncharted2ToneMapping(vec3 color ) {\n"

			// John Hable's filmic operator from Uncharted 2 video game
			" color *= toneMappingExposure;\n"
			" return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(1.0/*toneMappingWhitePoint*/)));\n"

			"}\n"
			"vec3 OptimizedCineonToneMapping(vec3 color ) {\n"

			// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
			"   color *= toneMappingExposure;\n"
			"  color = max(vec3(0.0), color - 0.004);\n"
			"   return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n"

			"}\n";
		m_shaderChunks["tonemapping_fragment"] = 
			"#if defined(TONE_MAPPING)\n"

			"   gl_FragColor.rgb = OptimizedCineonToneMapping(gl_FragColor.rgb);\n"

			"#endif\n";
		m_shaderChunks["clip_pars_fragment"] =
			"#if defined(USE_CLIP)\n"
			"uniform vec4 u_clipPlanes[3];\n"
			"uniform bool u_enableClips[3];\n"
			"uniform bool u_reverseClip;\n"
			"#endif\n"
			;
		m_shaderChunks["clip_fragment"] = 
			"#if defined(USE_CLIP)\n"
			"if (u_reverseClip)\n"
			"{\n"
			"	int iEnableNum = 0;\n"
			"	int iClipNum = 0;\n"
			"	for (int i = 0; i < 3; i++)\n"
			"	{\n"
			"		if (u_enableClips[i])\n"
			"		{\n"
			"			iEnableNum++;\n"
			"			float dPara = u_clipPlanes[i].w;\n"
			"			if ((dot(-vec3(vViewPosition.xyz), vec3(u_clipPlanes[i].xyz)) + dPara) > 0.0)\n"
			"			{\n"
			"				iClipNum++;\n"
			"			}\n"
			"		}\n"
			"	}\n"
			"	if (iEnableNum == iClipNum && iEnableNum != 0)\n"
			"	{\n"
					//if (u_enableClip[2] == 1) {
			"		discard;\n"
			"	}\n"
			"}\n"
			"else\n"
			"{\n"
			"	for (int i = 0; i < 3; i++)\n"
			"	{\n"
			"		if (u_enableClips[i])\n"
			"		{\n"
			"			float dPara = u_clipPlanes[i].w;\n"
			"			if ((dot(-vec3(vViewPosition.xyz), vec3(u_clipPlanes[i].xyz)) + dPara) < 0.0)\n"
			"			{\n"
			"				discard;\n"
			"			}\n"
			"		}\n"
			"	}\n"
			"}\n"
			"#endif\n"
			;
		m_shaderChunks["displacementmap_pars_vertex"] = 
			"#ifdef USE_DISPLACEMENTMAP\n"
			"uniform sampler2D displacementMap;\n"
			"uniform float displacementScale;\n"
			"uniform float displacementBias;\n"
			"#endif\n"
			;
		m_shaderChunks["displacementmap_vertex"] = 
			"#ifdef USE_DISPLACEMENTMAP\n"
			"transformed += normalize( objectNormal ) * ( texture2D( displacementMap, a_texCoords.xy ).x * displacementScale + displacementBias );\n"
			"#endif\n"
			;
		m_shaderChunks["aomap_pars_fragment"] = 
			""
			"#ifdef USE_AOMAP\n"
			"	uniform sampler2D aoMap;\n"
			"	uniform float aoMapIntensity;\n"
			"#endif\n"
			;
		m_shaderChunks["aomap_fragment"] = 
			""
			"#ifdef USE_AOMAP\n"

			// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
			"		float ambientOcclusion = (texture2D(aoMap, vUv).r - 1.0) * aoMapIntensity + 1.0;\n"//TODO用第二套uv

			"		reflectedLight.indirectDiffuse *= ambientOcclusion;\n"

			"#if defined( USE_ENV_TEXTURE ) && defined( PHYSICAL )\n"

			"		float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n"

			"		reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n"

			"#endif\n"

			"#endif\n"
			;
		m_shaderChunks["emissivemap_fragment"] = 
			""
			"#ifdef USE_EMISSIVEMAP\n"
			"		vec4 emissiveColor = texture2D(emissiveMap, vUv);\n"
			"		emissiveColor.rgb = mapTexelToLinear(emissiveColor).rgb;\n"//TODO----------------emissiveMapTexelToLinear
			"		totalEmissiveRadiance *= emissiveColor.rgb;\n"
			"#endif\n"
			;
		m_shaderChunks["emissivemap_pars_fragment"] = 
			""
			"#ifdef USE_EMISSIVEMAP\n"
			"		uniform sampler2D emissiveMap;\n"
			"#endif\n"
			;
		m_shaderChunks["parallax_corrected_cubemap_pars_vertex"] = 
			"#ifdef USE_LOCAL_CUBEMAP\n"
			"               varying vec3 vWorldPosition;\n"
			"#endif\n"
			;
		m_shaderChunks["parallax_corrected_cubemap_vertex"] = 
			"#ifdef USE_LOCAL_CUBEMAP\n"
			"               vWorldPosition = worldPosition.xyz;\n"
			"#endif\n"
			;
		m_shaderChunks["parallax_corrected_cubemap_pars_fragment"] =
			"#ifdef USE_LOCAL_CUBEMAP\n"
			" uniform vec3 boxMax;\n"
			" uniform vec3 boxMin;\n"
			" uniform vec3 cubeMapWorldPosition;\n"
			" varying vec3 vWorldPosition;\n"
			" vec3 GetParallaxCorrectedReflect(vec3 originReflect,vec3 boxMax,vec3 boxMin,vec3 cubeMapWorldPosition,vec3 worldPosition)\n"
			" {\n"
			//"   vec3 FirstPlaneIntersect = (boxMax - worldPosition) / originReflect;\n"
			//"   vec3 SecondPlaneIntersect = (boxMin - worldPosition) / originReflect;\n"
			//"	vec3 FurthestPlane = max(FirstPlaneIntersect, SecondPlaneIntersect);\n"
			//"	float Distance = min(min(FurthestPlane.x, FurthestPlane.y), FurthestPlane.z);\n"
			//"	vec3 IntersectPositionWS = worldPosition + originReflect * Distance;\n"
			//"	return (IntersectPositionWS - cubeMapWorldPosition);\n"
			" vec3 rbmax = (boxMax - worldPosition) / originReflect;\n"
			"vec3 rbmin = (boxMin - worldPosition) / originReflect;"
			"vec3 rbminmax;\n"
			"rbminmax.x = originReflect.x > 0.0 ? rbmax.x : rbmin.x;\n"
			"rbminmax.y = originReflect.y > 0.0 ? rbmax.y : rbmin.y;\n"
			"rbminmax.z = originReflect.z > 0.0 ? rbmax.z : rbmin.z;\n"
			" float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n"
			"vec3 posonbox = worldPosition + originReflect * fa;\n"
			" vec3 envBoxPos = (boxMin + boxMax) * 0.5;\n"
			" return posonbox - envBoxPos;\n"
			" }\n"
			"vec3 fixSeams(vec3 vec, float mipmapIndex) {\n"
			"float scale = 1.0 - exp2(mipmapIndex) / 256.0;\n"
			"float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n"
			"if (abs(vec.x) != M) vec.x *= scale;\n"
			"if (abs(vec.y) != M) vec.y *= scale;\n"
			"if (abs(vec.z) != M) vec.z *= scale;\n"
			"return vec;\n"
			"}\n"
			"#endif\n"
			;
		m_shaderChunks["encodings_pars_fragment"] = 
			""
			// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

			"vec4 LinearToLinear(in vec4 value) {\n"
			"return value;\n"
			"}\n"

			"vec4 GammaToLinear(in vec4 value, in float gammaFactor) {\n"
			"	return vec4(pow(value.xyz, vec3(gammaFactor)), value.w);\n"
			"}\n"
			"vec4 LinearToGamma(in vec4 value, in float gammaFactor) {\n"
			"	return vec4(pow(value.xyz, vec3(1.0 / gammaFactor)), value.w);\n"
			"}\n"

			"vec4 sRGBToLinear(in vec4 value) {\n"
			"	return vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.w);\n"
			"}\n"
			"vec4 LinearTosRGB(in vec4 value) {\n"
			"	return vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.w);\n"
			"}\n"

			"vec4 RGBEToLinear(in vec4 value) {\n"
			"	return vec4(value.rgb * exp2(value.a * 255.0 - 128.0), 1.0);\n"
			"}\n"
			"vec4 LinearToRGBE(in vec4 value) {\n"
			"	float maxComponent = max(max(value.r, value.g), value.b);\n"
			"	float fExp = clamp(ceil(log2(maxComponent)), -128.0, 127.0);\n"
			"	return vec4(value.rgb / exp2(fExp), (fExp + 128.0) / 255.0);\n"
			//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
			"}\n"

		// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
			"vec4 RGBMToLinear(in vec4 value, in float maxRange) {\n"
			"	return vec4(value.xyz * value.w * maxRange, 1.0);\n"
			"}\n"
			"vec4 LinearToRGBM(in vec4 value, in float maxRange) {\n"
			"	float maxRGB = max(value.x, max(value.g, value.b));\n"
			"	float M = clamp(maxRGB / maxRange, 0.0, 1.0);\n"
			"	M = ceil(M * 255.0) / 255.0;\n"
			"	return vec4(value.rgb / (M * maxRange), M);\n"
			"}\n"

		// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
			"vec4 RGBDToLinear(in vec4 value, in float maxRange) {\n"
			"	return vec4(value.rgb * ((maxRange / 255.0) / value.a), 1.0);\n"
			"}\n"
			"vec4 LinearToRGBD(in vec4 value, in float maxRange) {\n"
			"	float maxRGB = max(value.x, max(value.g, value.b));\n"
			"	float D = max(maxRange / maxRGB, 1.0);\n"
			"	D = min(floor(D) / 255.0, 1.0);\n"
			"	return vec4(value.rgb * (D * (255.0 / maxRange)), D);\n"
			"}\n"

		// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

		// M matrix, for encoding
			"const mat3 cLogLuvM = mat3(0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969);\n"
			"vec4 LinearToLogLuv(in vec4 value) {\n"
			"	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n"
			"	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n"
			"	vec4 vResult;\n"
			"	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n"
			"	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n"
			"	vResult.w = fract(Le);\n"
			"	vResult.z = (Le - (floor(vResult.w*255.0)) / 255.0) / 255.0;\n"
			"	return vResult;\n"
			"}\n"

		// Inverse M matrix, for decoding
			"const mat3 cLogLuvInverseM = mat3(6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268);\n"
			"vec4 LogLuvToLinear(in vec4 value) {\n"
			"	float Le = value.z * 255.0 + value.w;\n"
			"	vec3 Xp_Y_XYZp;\n"
			"	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n"
			"	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n"
			"	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n"
			"	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n"
			"	return vec4(max(vRGB, 0.0), 1.0);\n"
			"}\n"
			;
		m_shaderChunks["encodings_fragment"] = 
			" gl_FragColor = linearToOutputTexel( gl_FragColor );\n"
			;
		m_shaderChunks["ssao_par_fragment"] =
			"#ifdef SSAO\n"
			" uniform vec2 screenSize;\n"
			" uniform sampler2D ssaoMap;\n"
			"vec2 CalcScreenTexCoord()\n"
			"{\n"
			"	return gl_FragCoord.xy / screenSize;\n"
			"}\n"
			"#endif\n"
			;
		m_shaderChunks["ssao_fragment"] =
			"#ifdef SSAO\n"
			" ssaoFactor = texture2D(ssaoMap,CalcScreenTexCoord()).r;\n"
			"#endif\n"
			;
		m_shaderChunks["matcap_pars_fragment"] =
			"#if defined( USE_MATCAPMAP ) &&  !defined( PHYSICAL )\n"
			"uniform sampler2D matcapMap;\n"
			"vec3 GetMatcapIndirectLight( const in GeometricContext geometry)\n"
			"{\n"
			"  vec2 matcapCoords = -normalize(geometry.normal).xy*0.5+0.5;\n"
			"  vec3 ret = texture2D(matcapMap,matcapCoords).xyz;\n"
			//"#ifndef PHYSICALLY_CORRECT_LIGHTS\n"
			//"		ret *= PI;\n"
			//"#endif\n"
			" return ret;\n"
			"}\n"
			"#endif\n"
			;
		//m_shaderChunks["matcap_fragment"] = "";
		//m_shaderChunks[""] = "";
		//m_shaderChunks[""] = "";
		//m_shaderChunks[""] = "";
		//m_shaderChunks[""] = "";
		//m_shaderChunks[""] = "";

	}

	void ShaderChunk::Clear()
	{
		m_shaderChunks.clear();
	}

}
