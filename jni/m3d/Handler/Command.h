#ifndef M3DMANIPULATOR_COMMAND
#define M3DMANIPULATOR_COMMAND 1
#include <vector>
#include "m3d/M3DExport.h"
#include "m3d/base/Matrix3x4.h"
#include "m3d/model/Line3D.h"
#include "m3d/base/Plane.h"

namespace M3D {
	class Dragger;
/** Base class for motion commands that are generated by draggers. */
class M3D_API MotionCommand:public Object
{
    public:
        /**
         * Motion command are based on click-drag-release actions. So each
         * command needs to indicate which stage of the motion the command
         * represents.
         */
		 enum   Stage
        {
            NONE,
            /** Click or pick start. */
            START,  
            /** Drag or pick move. */
            MOVE,
            /** Release or pick finish. */
            FINISH
        };

		 enum   Type
		 {
		 Type_NONE,
	     TYPE_TRANSLATELINE,
		 TYPE_TRANSLATEINPLANE,
		 TYPE_SCALE1D,
		 TYPE_SCALE2D,
		 TYPE_SCALEUNIFROM,
		 TYPE_ROTATE3D
		 };

        MotionCommand();

        /** create a MotionCommand that is the inverse of this command, and if applied will undo this commands changes. */
        virtual MotionCommand* createCommandInverse() = 0;
 
        /**
         * Sets the matrix for transforming the command's local coordinate
         * system to the world/object coordinate system.
         */
        void setLocalToWorldAndWorldToLocal(const M3D::Matrix3x4& localToWorld, const M3D::Matrix3x4& worldToLocal)
        {
            _localToWorld = localToWorld;
            _worldToLocal = worldToLocal;
        }

        /**
         * Gets the matrix for transforming the command's local coordinate
         * system to the world/object coordinate system.
         */
        inline const M3D::Matrix3x4& getLocalToWorld() const { return _localToWorld; }

        /**
         * Gets the matrix for transforming the command's world/object
         * coordinate system to the command's local coordinate system. 
         */
        inline const M3D::Matrix3x4& getWorldToLocal() const { return _worldToLocal; }

        void setStage(const Stage s) { _stage = s; }
        Stage getStage() const { return _stage; }

		virtual MotionCommand::Type GetType() const {
			return MotionCommand::Type::Type_NONE;
		}

		Dragger* GetRefDragger() const;
		void SetRefDragger(Dragger* val);

    protected:

        virtual ~MotionCommand();
        
    private:
        M3D::Matrix3x4     _localToWorld;
        M3D::Matrix3x4     _worldToLocal;

        Stage           _stage;

		Dragger* _refDragger;
};


/**
 * Command for translating in a line.
 */
class M3D_API TranslateInLineCommand : public MotionCommand
{
    public:

        TranslateInLineCommand();

        TranslateInLineCommand(const M3D::Vector3& s,const M3D::Vector3& e);

        virtual MotionCommand* createCommandInverse();

        inline void setLine(const M3D::Vector3& s,const M3D::Vector3& e) { _line.m_StartPoint = s; _line.m_EndPoint = e; }
        inline const M3D::Vector3& getLineStart() const { return _line.m_StartPoint; }
        inline const M3D::Vector3& getLineEnd() const { return _line.m_EndPoint; }

        inline void setTranslation(const M3D::Vector3& t) { _translation = t; }
        inline const M3D::Vector3& getTranslation() const { return _translation; }
 
		virtual MotionCommand::Type GetType()const {
			return MotionCommand::Type::TYPE_TRANSLATELINE;
		}
    protected:

        virtual ~TranslateInLineCommand();

    private:
        M3D::Line3D  _line;
        M3D::Vector3                      _translation;
};

/**
 * Command for translating in a plane.
 */
class M3D_API TranslateInPlaneCommand : public MotionCommand
{
    public:

        TranslateInPlaneCommand();

        TranslateInPlaneCommand(const M3D::Plane& plane);

        virtual MotionCommand* createCommandInverse();

        inline void setPlane(const M3D::Plane& plane) { _plane = plane; }
        inline const M3D::Plane& getPlane() const { return _plane; }

        inline void setTranslation(const M3D::Vector3& t) { _translation = t; }
        inline const M3D::Vector3& getTranslation() const { return _translation; }

        /** ReferencePoint is used only for snapping. */
        inline void setReferencePoint(const M3D::Vector3& rp) { _referencePoint = rp; }
        inline const M3D::Vector3& getReferencePoint() const { return _referencePoint; }
 
		virtual MotionCommand::Type GetType() const {
			return MotionCommand::Type::TYPE_TRANSLATEINPLANE;
		}
    protected:

        virtual ~TranslateInPlaneCommand();

    private:
        M3D::Plane _plane;
        M3D::Vector3 _translation;
        M3D::Vector3 _referencePoint;
};

/**
 * Command for 1D scaling.
 */
class M3D_API Scale1DCommand : public MotionCommand
{
    public:

        Scale1DCommand();

        virtual MotionCommand* createCommandInverse();

        inline void setDeltaScale(double s) { _deltaScale = s; }
        inline double getDeltaScale() const { return  _deltaScale; }

        inline void  setScaleCenter(double center) { _scaleCenter = center; }
        inline double getScaleCenter() const       { return _scaleCenter; }

        /** ReferencePoint is used only for snapping. */
        inline void  setReferencePoint(double rp) { _referencePoint = rp; }
        inline double getReferencePoint() const   { return _referencePoint; }

        inline void  setMinScale(double min) { _minScale = min; }
        inline double getMinScale() const    { return _minScale; }
 
		virtual MotionCommand::Type GetType()const {
			return MotionCommand::Type::TYPE_SCALE1D;
		}
		M3D::Vector3 getTranslation() const { return _translation; }
		void setTranslation(M3D::Vector3 val) { _translation = val; }
		double GetScale() const { return _scale; }
		void SetScale(double val) { _scale = val; }
protected:

        virtual ~Scale1DCommand();

    private:
		double    _scale;
        double     _deltaScale;
        double     _scaleCenter;
        double     _referencePoint;
        double     _minScale;

		M3D::Vector3   _translation;
};

/**
 * Command for 2D scaling.
 */
class M3D_API Scale2DCommand : public MotionCommand
{
    public:

        Scale2DCommand();

        virtual MotionCommand* createCommandInverse();

        inline void setDeltaScale(const M3D::Vector2& s) { _scale = s; }
        inline const M3D::Vector2& getDeltaScale() const { return _scale; }

        inline void setScaleCenter(const M3D::Vector2& center) { _scaleCenter = center; }
        inline const M3D::Vector2& getScaleCenter() const { return _scaleCenter; }

        /** ReferencePoint is used only for snapping. */
        inline void  setReferencePoint(const M3D::Vector2& rp) { _referencePoint = rp; }
        inline const M3D::Vector2& getReferencePoint() const   { return _referencePoint; }

        inline void             setMinScale(const M3D::Vector2& min) { _minScale = min; }
        inline const M3D::Vector2& getMinScale() const               { return _minScale; }
 
		virtual MotionCommand::Type GetType()const {
			return MotionCommand::Type::TYPE_SCALE2D;
		}

		M3D::Vector3 getTranslation() const { return _translation; }
		void setTranslation(M3D::Vector3 val) { _translation = val; }

    protected:

        virtual ~Scale2DCommand();

    private:
        M3D::Vector2   _scale;
        M3D::Vector2   _scaleCenter;
        M3D::Vector2   _referencePoint;
        M3D::Vector2   _minScale;
		M3D::Vector3   _translation;
};

/**
 * Command for uniform 3D scaling.
 */
class M3D_API ScaleUniformCommand : public MotionCommand
{
    public:

        ScaleUniformCommand();

        virtual MotionCommand* createCommandInverse();

        inline void setDeltaScale(double s) { _scale = s; }
        inline double getDeltaScale() const { return _scale; }

        inline void setScaleCenter(const M3D::Vector3& center) { _scaleCenter = center; }
        inline const M3D::Vector3& getScaleCenter() const { return _scaleCenter; }
 
		virtual MotionCommand::Type GetType() const {
			return MotionCommand::Type::TYPE_SCALEUNIFROM;
		}

		M3D::Vector3 getTranslation() const { return _translation; }
		void setTranslation(M3D::Vector3 val) { _translation = val; }
    protected:

        virtual ~ScaleUniformCommand();

    private:
        double     _scale;
        M3D::Vector3 _scaleCenter;
		M3D::Vector3   _translation;
};

/**
 * Command for rotation in 3D.
 */
class M3D_API Rotate3DCommand : public MotionCommand
{
    public:

        Rotate3DCommand();

        virtual MotionCommand* createCommandInverse();

        inline void setRotation(const M3D::Quaternion& rotation) { _rotation = rotation; }
        inline const M3D::Quaternion& getRotation() const { return _rotation; }
 
		inline void setDeltaRotation(const M3D::Quaternion& rotation) { _deltarotation = rotation; }
		inline const M3D::Quaternion& getDeltaRotation() const { return _deltarotation; }
 
		virtual MotionCommand::Type GetType() const {
			return MotionCommand::Type::TYPE_ROTATE3D;
		}
    protected:

        virtual ~Rotate3DCommand();

    private:
        M3D::Quaternion _rotation;
		M3D::Quaternion _deltarotation;
};


}

#endif
